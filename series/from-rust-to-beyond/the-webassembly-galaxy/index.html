<!doctype html>
<html lang="en">
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta http-equiv="content-security-policy" content="default-src 'self'; child-src 'self' https://www.youtube-nocookie.com; script-src 'self' 'unsafe-inline' 'wasm-unsafe-eval'; style-src 'self' 'unsafe-inline'; img-src 'self' data:">
  <meta name="viewport" content="width=device-width, minimum-scale=1">

  <title>The WebAssembly galaxy</title>

  <link rel="stylesheet" href="https://mnt.io/style/min/main.css?h=6b87d11f3c4205ed0f3a">
  <link rel="stylesheet" href="https://mnt.io/style/min/syntax-theme.css?h=ef9797b0398b3ffe9058">
  <link rel="stylesheet" href="https://mnt.io/style/min/search.css" fetchpriority="low">

  <meta name="author" content="Ivan Enderlin">
  <meta name="description" content="In this episode, we explore the WebAssembly galaxy.

We first off present WebAssembly. Then we see how to write a Rust program tailored for WebAssembly. We continue by explaining how to run this WebAssembly module on a JavaScript host. It brings some complications, like how to flatten an Abstract Syntax Tree to get fast memory accesses between Rust and JavaScript. We continue by reducing the size of the WebAssembly module to make it as small as possible, smaller than a tiny image. Finally, we compare performance of this Rust to WebAssembly to JavaScript design versus the original PEG.js solution: is it faster? Oh yeah‚Ä¶ it is!">
  <meta name="keywords" content="rust, binding, gutenberg, webassembly, javascript, asmjs">
  <meta property="og:title" content="The WebAssembly galaxy ‚Äî from the series From Rust to beyond">
  <meta property="og:site_name" content="mnt.io">
  <meta property="og:locale" content="en_GB">
  <meta property="og:type" content="article">
  <meta property="og:url" content="https://mnt.io/series/from-rust-to-beyond/the-webassembly-galaxy/">
  <meta property="og:image" content="https://mnt.io/image/site-poster.jpg">
  <meta name="fediverse:creator" content="@hywan@floss.social">

  <script defer src="https://mnt.io/search/pagefind-ui.js" fetchpriority="low"></script>
</head>
<body class="content-grid">

<nav id="menu" class="full-width content-grid">
  <ul>
    <li><a href="/" accesskey="h">Home</a></li>
    <li><a href="https://mnt.io/articles/" accesskey="a">Articles</a></li>
    <li><a href="https://mnt.io/series/" accesskey="s">Series</a></li>
    <li><a href="https://matrix.to/#/&#x23;mnt_io:matrix.org" title="Public Matrix room to discuss about this blog's content" target="_blank" accesskey="d">Discuss</a></li>
    <li>
      <a href="javascript:document.getElementById('search').showModal()" accesskey="k">
        <svg viewBox="0 0 500 500" class="icon">
          <description>Search</description>
          <circle r="180" cx="210" cy="210" fill="none" stroke="currentColor" stroke-width="40" />
          <line x1="340" y1="340" x2="480" y2="480" stroke="currentColor" stroke-width="40" stroke-linecap="round" />
        </svg>
      </a>
    </li>
  </ul>
</nav>

<dialog id="search" tabindex="-1" closedby="any"></dialog>

<main vocab="https://schema.org">

  <article class="series-episode" typeof="Article" data-pagefind-body>
    <header>
      <h1 property="name" style="view-transition-name: series-episode-title-the-webassembly-galaxy">The WebAssembly galaxy</h1>

      <nav property="isPartOf" typeof="CreativeWorkSeries">
        <p>From the series <a href="/series/from-rust-to-beyond/" property="url"><span property="name">From Rust to beyond</span></a>.</p>
      </nav>

      
  <div class="metadata" data-pagefind-ignore="all">
    <time title="Published date" datetime="2018-08-22" property="datePublished">August 22, 2018</time>
    <span title="Reading time" property="timeRequired" content="PT18M">18 minutes read</span>
    
    <span title="Keywords" property="keywords" content="rust, binding, gutenberg, webassembly, javascript, asmjs">
      Keywords:&nbsp;<a href="/keywords/rust">rust</a>, <a href="/keywords/binding">binding</a>, <a href="/keywords/gutenberg">gutenberg</a>, <a href="/keywords/webassembly">webassembly</a>, <a href="/keywords/javascript">javascript</a>, <a href="/keywords/asmjs">asmjs</a></span>
    
      <span><a href="https://github.com/Hywan/mnt.io/edit/main/content/series&#x2F;from-rust-to-beyond&#x2F;2018-08-22-the-webassembly-galaxy&#x2F;index.md" title="Submit a patch for this page">Edit</a> this page</span>
      
      <meta property="description" content="In this episode, we explore the WebAssembly galaxy.

We first off present WebAssembly. Then we see how to write a Rust program tailored for WebAssembly. We continue by explaining how to run this WebAssembly module on a JavaScript host. It brings some complications, like how to flatten an Abstract Syntax Tree to get fast memory accesses between Rust and JavaScript. We continue by reducing the size of the WebAssembly module to make it as small as possible, smaller than a tiny image. Finally, we compare performance of this Rust to WebAssembly to JavaScript design versus the original PEG.js solution: is it faster? Oh yeah‚Ä¶ it is!" />
      
    
  </div>

    </header>

    <p>The first galaxy that our Rust parser will explore is the WebAssembly
(Wasm) galaxy. This post will explain what WebAssembly is, how to
compile the parser into WebAssembly, and how to use the WebAssembly
binary with Javascript in a browser and with NodeJS.</p>
<h2 id="what-is-webassembly-and-why">What is WebAssembly, and why?<a role="presentation" class="anchor" href="#what-is-webassembly-and-why" title="Anchor link to this header">#</a>
</h2>
<p>If you already know WebAssembly, you can skip this section.</p>
<p><a rel="noopener external" target="_blank" href="https://webassembly.org/">WebAssembly</a> defines itself as:</p>
<blockquote>
<p>WebAssembly (abbreviated <em>Wasm</em>) is a binary instruction format for a
stack-based virtual machine. Wasm is designed as a portable target for
compilation of high-level languages like C/C++/Rust, enabling
deployment on the web for client and server applications.</p>
</blockquote>
<p>Should I say more? Probably, yes‚Ä¶</p>
<p>WebAssembly is a <em>new portable binary format</em>. Languages like C, C++, or
Rust already compiles to this target. It is the spirit successor of
<a rel="noopener external" target="_blank" href="http://asmjs.org/">ASM.js</a>. By spirit successor, I mean it is the same
people trying to extend the Web platform and to make the Web fast that
are working on both technologies. They share some design concepts too,
but that's not really important right now.</p>
<p>Before WebAssembly, programs had to compile to Javascript in order to
run on the Web platform. The resulting files were most of the time
large. And because the Web is a network, the files had to be downloaded,
and it took time. WebAssembly is designed to be encoded in a size- and
load-time efficient <a rel="noopener external" target="_blank" href="https://webassembly.org/docs/binary-encoding/">binary
format</a>.</p>
<p>WebAssembly is also faster than Javascript for many reasons. Despites
all the crazy optimisations engineers put in the Javascript virtual
machines, Javascript is a weakly and dynamically typed language, which
requires to be interpreted. WebAssembly aims to execute at native speed
by taking advantage of <a rel="noopener external" target="_blank" href="https://webassembly.org/docs/portability/#assumptions-for-efficient-execution">common hardware
capabilities</a>.
<a rel="noopener external" target="_blank" href="https://hacks.mozilla.org/2018/01/making-webassembly-even-faster-firefoxs-new-streaming-and-tiering-compiler/">WebAssembly also loads faster than
Javascript</a>
because parsing and compiling happen while the binary is streamed from
the network. So once the binary is entirely fetched, it is ready to run:
No need to wait on the parser and the compiler before running the
program.</p>
<p>Today, and our blog series is a perfect example of that, it is possible
to write a Rust program, and to compile it to run on the Web platform.
Why? Because WebAssembly is implemented by <a rel="noopener external" target="_blank" href="https://caniuse.com/#search=wasm">all major
browsers</a>, and because it has been
designed for the Web: To live and run on the Web platform (like a
browser). But its portable aspect and <a rel="noopener external" target="_blank" href="https://webassembly.org/docs/semantics/#linear-memory">its safe and sandboxed memory
design</a> make it a
good candidate to run outside of the Web platform (see <a rel="noopener external" target="_blank" href="https://github.com/geal/serverless-wasm">a serverless
Wasm framework</a>, or <a rel="noopener external" target="_blank" href="https://github.com/losfair/IceCore">an
application container built for
Wasm</a>).</p>
<p>I think it is important to remind that WebAssembly is not here to
replace Javascript. It is just another technology which solves many
problems we can meet today, like load-time, safety, or speed.</p>
<h2 id="rust-rocket-webassembly">Rust üöÄ WebAssembly<a role="presentation" class="anchor" href="#rust-rocket-webassembly" title="Anchor link to this header">#</a>
</h2>
<figure role="presentation">
<p><img src="https://mnt.io/series/from-rust-to-beyond/the-webassembly-galaxy/./rust-to-wasm.png" alt="Rust to Wasm" loading="lazy" decoding="async" /></p>
</figure>
<p><a rel="noopener external" target="_blank" href="https://github.com/rustwasm/team">The Rust Wasm team</a> is a group of
people leading the effort of pushing Rust into WebAssembly with a set of
tools and integrations. <a rel="noopener external" target="_blank" href="https://rustwasm.github.io/book/">There is a
book</a> explaining how to write a
WebAssembly program with Rust.</p>
<p>With the Gutenberg Rust parser, I didn&#39;t use tools like
<a rel="noopener external" target="_blank" href="https://github.com/rustwasm/wasm-bindgen/"><code>wasm-bindgen</code></a> (which is a
pure gem) when I started the project few months ago because I hit some
limitations. Note that some of them have been addressed since then!
Anyway, we will do most of the work by hand, and I think this is an
excellent way to understand how things work in the background. When you
are familiar with WebAssembly interactions, then <code>wasm-bindgen</code> is an
excellent tool to have within easy reach, because it abstracts all the
interactions and let you focus on your code logic instead.</p>
<p>I would like to remind the reader that the Gutenberg Rust parser exposes
one AST, and one <code>root</code> function (the axiom of the grammar),
respectively defined as:</p>
<pre class="giallo z-code"><code data-lang="rust"><span class="giallo-l"><span class="z-keyword">pub</span><span class="z-storage"> enum</span><span class="z-entity z-name"> Node</span><span>&lt;&#39;</span><span class="z-entity z-name">a</span><span>&gt; {</span></span>
<span class="giallo-l"><span class="z-entity z-name">    Block</span><span> {</span></span>
<span class="giallo-l"><span class="z-variable">        name</span><span class="z-keyword z-operator">:</span><span> (</span><span class="z-entity z-name">Input</span><span>&lt;&#39;</span><span class="z-entity z-name">a</span><span>&gt;,</span><span class="z-entity z-name"> Input</span><span>&lt;&#39;</span><span class="z-entity z-name">a</span><span>&gt;),</span></span>
<span class="giallo-l"><span class="z-variable">        attributes</span><span class="z-keyword z-operator">:</span><span class="z-entity z-name"> Option</span><span>&lt;</span><span class="z-entity z-name">Input</span><span>&lt;&#39;</span><span class="z-entity z-name">a</span><span>&gt;&gt;,</span></span>
<span class="giallo-l"><span class="z-variable">        children</span><span class="z-keyword z-operator">:</span><span class="z-entity z-name"> Vec</span><span>&lt;</span><span class="z-entity z-name">Node</span><span>&lt;&#39;</span><span class="z-entity z-name">a</span><span>&gt;&gt;</span></span>
<span class="giallo-l"><span>    },</span></span>
<span class="giallo-l"><span class="z-entity z-name z-function">    Phrase</span><span>(</span><span class="z-entity z-name">Input</span><span>&lt;&#39;</span><span class="z-entity z-name">a</span><span>&gt;)</span></span>
<span class="giallo-l"><span>}</span></span></code></pre>
<p>and</p>
<pre class="giallo z-code"><code data-lang="rust"><span class="giallo-l"><span class="z-keyword">pub fn</span><span class="z-entity z-name z-function"> root</span><span>(</span></span>
<span class="giallo-l"><span class="z-variable">    input</span><span class="z-keyword z-operator">:</span><span class="z-entity z-name"> Input</span></span>
<span class="giallo-l"><span>)</span><span class="z-keyword z-operator"> -&gt;</span><span class="z-entity z-name"> Result</span><span>&lt;(</span><span class="z-entity z-name">Input</span><span>,</span><span class="z-entity z-name"> Vec</span><span>&lt;</span><span class="z-variable">ast</span><span class="z-keyword z-operator">::</span><span class="z-entity z-name">Node</span><span>&gt;),</span><span class="z-variable"> nom</span><span class="z-keyword z-operator">::</span><span class="z-entity z-name">Err</span><span>&lt;</span><span class="z-entity z-name">Input</span><span>&gt;&gt;;</span></span></code></pre>
<p>Knowing that, let&#39;s go!</p>
<h3 id="">General design<a role="presentation" class="anchor" href="#" title="Anchor link to this header">#</a>
</h3>
<p>Here is our general design or workflow:</p>
<ol>
<li>Javascript (for instance) writes the blog post to parse into the WebAssembly
module memory,</li>
<li>Javascript runs the <code>root</code> function by passing a pointer to the memory, and
the length of the blog post,</li>
<li>Rust reads the blog post from the memory, runs the Gutenberg parser, compiles
the resulting AST into a sequence of bytes, and returns the pointer to this
sequence of bytes to Javascript,</li>
<li>Javascript reads the memory from the received pointer, and decodes the
sequence of bytes as Javascript objects in order to recreate an AST with a
friendly API.</li>
</ol>
<p>Why a sequence of bytes? Because WebAssembly only supports integers and
floats, not strings or vectors, and also because our Rust parser takes a
slice of bytes as input, so this is handy.</p>
<p>We use the term <em>boundary layer</em> to refer to this Javascript piece of
code responsible to read from and write into the WebAssembly module
memory, and responsible of exposing a friendly API.</p>
<p>Now, we will focus on the Rust code. It consists of only 4 functions:</p>
<ul>
<li><code>alloc</code> to allocate memory (exported),</li>
<li><code>dealloc</code> to deallocate memory (exported),</li>
<li><code>root</code> to run the parser (exported),</li>
<li><code>into_bytes</code> to transform the AST into a sequence of bytes.</li>
</ul>
<p><a rel="noopener external" target="_blank" href="https://github.com/Hywan/gutenberg-parser-rs/blob/master/bindings/wasm/src/lib.rs">The entire code lands
here</a>.
It is approximately 150 lines of code. We explain it.</p>
<h3 id="-1">Memory allocation<a role="presentation" class="anchor" href="#-1" title="Anchor link to this header">#</a>
</h3>
<p>Let&#39;s start by the memory allocator. I choose to use <a rel="noopener external" target="_blank" href="https://github.com/rustwasm/wee_alloc"><code>wee_alloc</code> for
the memory allocator</a>. It is
specifically designed for WebAssembly by being very small (less than a
kilobyte) and efficient.</p>
<p>The following piece of code describes the memory allocator setup and the
‚Äúprelude‚Äù for our code (enabling some compiler features, like <code>alloc</code>,
declaring external crates, some aliases, and declaring required function
like <code>panic</code>, <code>oom</code> etc.). This can be considered as a boilerplate:</p>
<pre class="giallo z-code"><code data-lang="rust"><span class="giallo-l"><span>#![no_std]</span></span>
<span class="giallo-l"><span>#![feature(</span></span>
<span class="giallo-l"><span>    alloc,</span></span>
<span class="giallo-l"><span>    alloc_error_handler,</span></span>
<span class="giallo-l"><span>    core_intrinsics,</span></span>
<span class="giallo-l"><span>    lang_items</span></span>
<span class="giallo-l"><span>)]</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span class="z-storage">extern</span><span class="z-keyword"> crate</span><span> gutenberg_post_parser;</span></span>
<span class="giallo-l"><span class="z-storage">extern</span><span class="z-keyword"> crate</span><span> wee_alloc;</span></span>
<span class="giallo-l"><span>#[macro_use]</span><span class="z-storage"> extern</span><span class="z-keyword"> crate</span><span> alloc;</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span class="z-keyword">use</span><span class="z-entity z-name"> gutenberg_post_parser</span><span class="z-keyword z-operator">::</span><span class="z-entity z-name">ast</span><span class="z-keyword z-operator">::</span><span class="z-entity z-name">Node</span><span>;</span></span>
<span class="giallo-l"><span class="z-keyword">use</span><span class="z-entity z-name"> alloc</span><span class="z-keyword z-operator">::</span><span class="z-entity z-name">vec</span><span class="z-keyword z-operator">::</span><span class="z-entity z-name">Vec</span><span>;</span></span>
<span class="giallo-l"><span class="z-keyword">use</span><span class="z-entity z-name"> core</span><span class="z-keyword z-operator">::</span><span>{mem, slice};</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>#[global_allocator]</span></span>
<span class="giallo-l"><span class="z-storage">static</span><span class="z-constant z-other"> ALLOC</span><span class="z-keyword z-operator">:</span><span class="z-entity z-name"> wee_alloc</span><span class="z-keyword z-operator">::</span><span class="z-entity z-name">WeeAlloc</span><span class="z-keyword z-operator"> =</span><span class="z-entity z-name"> wee_alloc</span><span class="z-keyword z-operator">::</span><span class="z-entity z-name">WeeAlloc</span><span class="z-keyword z-operator">::</span><span class="z-constant z-other">INIT</span><span>;</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>#[panic_handler]</span></span>
<span class="giallo-l"><span class="z-keyword">fn</span><span class="z-entity z-name z-function"> panic</span><span>(</span><span class="z-variable">_info</span><span class="z-keyword z-operator">: &amp;</span><span class="z-entity z-name">core</span><span class="z-keyword z-operator">::</span><span class="z-entity z-name">panic</span><span class="z-keyword z-operator">::</span><span class="z-entity z-name">PanicInfo</span><span>)</span><span class="z-keyword z-operator"> -&gt; !</span><span> {</span></span>
<span class="giallo-l"><span class="z-keyword">    unsafe</span><span> {</span><span class="z-entity z-name"> core</span><span class="z-keyword z-operator">::</span><span class="z-entity z-name">intrinsics</span><span class="z-keyword z-operator">::</span><span class="z-entity z-name z-function">abort</span><span>(); }</span></span>
<span class="giallo-l"><span>}</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>#[alloc_error_handler]</span></span>
<span class="giallo-l"><span class="z-keyword">fn</span><span class="z-entity z-name z-function"> oom</span><span>(</span><span class="z-variable">_</span><span class="z-keyword z-operator">:</span><span class="z-entity z-name"> core</span><span class="z-keyword z-operator">::</span><span class="z-entity z-name">alloc</span><span class="z-keyword z-operator">::</span><span class="z-entity z-name">Layout</span><span>)</span><span class="z-keyword z-operator"> -&gt; !</span><span> {</span></span>
<span class="giallo-l"><span class="z-keyword">    unsafe</span><span> {</span><span class="z-entity z-name"> core</span><span class="z-keyword z-operator">::</span><span class="z-entity z-name">intrinsics</span><span class="z-keyword z-operator">::</span><span class="z-entity z-name z-function">abort</span><span>(); }</span></span>
<span class="giallo-l"><span>}</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span class="z-comment">// This is the definition of `std::ffi::c_void`, but Wasm runs without std in our case.</span></span>
<span class="giallo-l"><span>#[repr(</span><span class="z-entity z-name">u8</span><span>)]</span></span>
<span class="giallo-l"><span>#[allow(non_camel_case_types)]</span></span>
<span class="giallo-l"><span class="z-keyword">pub</span><span class="z-storage"> enum</span><span class="z-variable"> c_void</span><span> {</span></span>
<span class="giallo-l"><span>    #[doc(hidden)]</span></span>
<span class="giallo-l"><span class="z-variable">    __variant1</span><span>,</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    #[doc(hidden)]</span></span>
<span class="giallo-l"><span class="z-variable">    __variant2</span></span>
<span class="giallo-l"><span>}</span></span></code></pre>
<p>The Rust memory is the WebAssembly memory. Rust will allocate and
deallocate memory on its own, but Javascript for instance needs to
allocate and deallocate WebAssembly memory in order to
communicate/exchange data. So we need to export one function to allocate
memory and one function to deallocate memory.</p>
<p>Once again, this is almost a boilerplate. The <code>alloc</code> function creates
an empty vector of a specific capacity (because it is a linear segment
of memory), and returns a pointer to this empty vector:</p>
<pre class="giallo z-code"><code data-lang="rust"><span class="giallo-l"><span>#[no_mangle]</span></span>
<span class="giallo-l"><span class="z-keyword">pub</span><span class="z-storage"> extern</span><span class="z-string"> &quot;C&quot;</span><span class="z-keyword"> fn</span><span class="z-entity z-name z-function"> alloc</span><span>(</span><span class="z-variable">capacity</span><span class="z-keyword z-operator">:</span><span class="z-entity z-name"> usize</span><span>)</span><span class="z-keyword z-operator"> -&gt; *</span><span class="z-storage">mut</span><span class="z-variable"> c_void</span><span> {</span></span>
<span class="giallo-l"><span class="z-storage">  ¬† let mut</span><span class="z-variable"> buffer</span><span class="z-keyword z-operator"> =</span><span class="z-entity z-name"> Vec</span><span class="z-keyword z-operator">::</span><span class="z-entity z-name z-function">with_capacity</span><span>(</span><span class="z-variable">capacity</span><span>);</span></span>
<span class="giallo-l"><span class="z-storage">¬†   let</span><span class="z-variable"> pointer</span><span class="z-keyword z-operator"> =</span><span class="z-variable"> buffer</span><span class="z-keyword z-operator">.</span><span class="z-entity z-name z-function">as_mut_ptr</span><span>();</span></span>
<span class="giallo-l"><span class="z-entity z-name">¬†   mem</span><span class="z-keyword z-operator">::</span><span class="z-entity z-name z-function">forget</span><span>(</span><span class="z-variable">buffer</span><span>);</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span class="z-variable">¬†   pointer</span><span class="z-keyword"> as</span><span class="z-keyword z-operator"> *</span><span class="z-storage">mut</span><span class="z-variable"> c_void</span></span>
<span class="giallo-l"><span>}</span></span></code></pre>
<p>Note the <code>#[no_mangle]</code> attribute that instructs the Rust compiler to
not mangle the function name, i.e. to not rename it. And <code>extern "C"</code> to
export the function in the WebAssembly module, so it is ‚Äúpublic‚Äù from
outside the WebAssembly binary.</p>
<p>The code is pretty straightforward and matches what we announced
earlier: A <code>Vec</code> is allocated with a specific capacity, and the pointer
to this vector is returned. The important part is <code>mem::forget(buffer)</code>.
It is required so that Rust will <em>not</em> deallocate the vector once it
goes out of scope. Indeed, Rust enforces <a rel="noopener external" target="_blank" href="https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization">Resource Acquisition Is
Initialization
(RAII)</a>,
so whenever an object goes out of scope, its destructor is called and
its owned resources are freed. This behavior shields against resource
leaks bugs, and this is why we will never have to manually free memory
or worry about memory leaks in Rust (<a rel="noopener external" target="_blank" href="https://doc.rust-lang.org/rust-by-example/scope/raii.html">see some RAII
examples</a>).
In this case, we want to allocate and keep the allocation after the
function execution, hence <a rel="noopener external" target="_blank" href="https://doc.rust-lang.org/std/mem/fn.forget.html">the <code>mem::forget</code>
call</a>.</p>
<p>Let&#39;s jump on the <code>dealloc</code> function. The goal is to recreate a vector
based on a pointer and a capacity, and to let Rust drops it:</p>
<pre class="giallo z-code"><code data-lang="rust"><span class="giallo-l"><span>#[no_mangle]</span></span>
<span class="giallo-l"><span class="z-keyword">pub</span><span class="z-storage"> extern</span><span class="z-string"> &quot;C&quot;</span><span class="z-keyword"> fn</span><span class="z-entity z-name z-function"> dealloc</span><span>(</span><span class="z-variable">pointer</span><span class="z-keyword z-operator">: *</span><span class="z-storage">mut</span><span class="z-variable"> c_void</span><span>,</span><span class="z-variable"> capacity</span><span class="z-keyword z-operator">:</span><span class="z-entity z-name"> usize</span><span>) {</span></span>
<span class="giallo-l"><span class="z-keyword">  ¬† unsafe</span><span> {</span></span>
<span class="giallo-l"><span class="z-storage">¬†       let</span><span class="z-variable"> _</span><span class="z-keyword z-operator"> =</span><span class="z-entity z-name"> Vec</span><span class="z-keyword z-operator">::</span><span class="z-entity z-name z-function">from_raw_parts</span><span>(</span><span class="z-variable">pointer</span><span>,</span><span class="z-constant z-numeric"> 0</span><span>,</span><span class="z-variable"> capacity</span><span>);</span></span>
<span class="giallo-l"><span>    }</span></span>
<span class="giallo-l"><span>}</span></span></code></pre>
<p><a rel="noopener external" target="_blank" href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.from_raw_parts">The <code>Vec::from_raw_parts</code>
function</a>
is marked as unsafe, so we need to delimit it in an <code>unsafe</code> block so
that the <code>dealloc</code> function is considered as safe.</p>
<p>The variable <code>_</code> contains our data to deallocate, and it goes out of
scope immediately, so Rust drops it.</p>
<h3 id="-2">From input to a flat AST<a role="presentation" class="anchor" href="#-2" title="Anchor link to this header">#</a>
</h3>
<p>Now the core of the binding! The <code>root</code> function reads the blog post to
parse based on a pointer and a length, then it parses it. If the result
is OK, it serializes the AST into a sequence of bytes, i.e. it flatten
it, otherwise it returns an empty sequence of bytes.</p>
<figure>
<p><img src="https://mnt.io/series/from-rust-to-beyond/the-webassembly-galaxy/./flatten-ast.png" alt="Flatten AST" loading="lazy" decoding="async" /></p>
  <figcaption>
<p>The image illustrates the flow of the data: first off there is a blog post;
second there is the AST of the blog post; finally there is a linear byte-encoded
representation of the AST of the blog post.</p>
  </figcaption>
</figure>
<p>The logic flow of the parser: The input on the left is parsed into an
AST, which is serialized into a flat sequence of bytes on the right.</p>
<pre class="giallo z-code"><code data-lang="rust"><span class="giallo-l"><span>#[no_mangle]</span></span>
<span class="giallo-l"><span class="z-keyword">pub</span><span class="z-storage"> extern</span><span class="z-string"> &quot;C&quot;</span><span class="z-keyword"> fn</span><span class="z-entity z-name z-function"> root</span><span>(</span><span class="z-variable">pointer</span><span class="z-keyword z-operator">: *</span><span class="z-storage">mut</span><span class="z-entity z-name"> u8</span><span>,</span><span class="z-variable"> length</span><span class="z-keyword z-operator">:</span><span class="z-entity z-name"> usize</span><span>)</span><span class="z-keyword z-operator"> -&gt; *</span><span class="z-storage">mut</span><span class="z-entity z-name"> u8</span><span> {</span></span>
<span class="giallo-l"><span class="z-storage">    let</span><span class="z-variable"> input</span><span class="z-keyword z-operator"> =</span><span class="z-keyword"> unsafe</span><span> {</span><span class="z-entity z-name"> slice</span><span class="z-keyword z-operator">::</span><span class="z-entity z-name z-function">from_raw_parts</span><span>(</span><span class="z-variable">pointer</span><span>,</span><span class="z-variable"> length</span><span>) };</span></span>
<span class="giallo-l"><span class="z-storage">    let mut</span><span class="z-variable"> output</span><span class="z-keyword z-operator"> =</span><span class="z-entity z-name z-function"> vec!</span><span>[];</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span class="z-keyword">    if</span><span class="z-storage"> let</span><span class="z-entity z-name"> Ok</span><span>((</span><span class="z-variable">_remaining</span><span>,</span><span class="z-variable"> nodes</span><span>))</span><span class="z-keyword z-operator"> =</span><span class="z-entity z-name"> gutenberg_post_parser</span><span class="z-keyword z-operator">::</span><span class="z-entity z-name z-function">root</span><span>(</span><span class="z-variable">input</span><span>) {</span></span>
<span class="giallo-l"><span class="z-comment">        // Compile the AST (nodes) into a sequence of bytes.</span></span>
<span class="giallo-l"><span>    }</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span class="z-storage">    let</span><span class="z-variable"> pointer</span><span class="z-keyword z-operator"> =</span><span class="z-variable"> output</span><span class="z-keyword z-operator">.</span><span class="z-entity z-name z-function">as_mut_ptr</span><span>();</span></span>
<span class="giallo-l"><span class="z-entity z-name">    mem</span><span class="z-keyword z-operator">::</span><span class="z-entity z-name z-function">forget</span><span>(</span><span class="z-variable">output</span><span>);</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span class="z-variable">    pointer</span></span>
<span class="giallo-l"><span>}</span></span></code></pre>
<p>The variable <code>input</code> contains the blog post. It is fetched from memory
with a pointer and a length. The variable <code>output</code> is the sequence of
bytes the function will return. <code>gutenberg_post_parser::root(input)</code>
runs the parser. If parsing is OK, then the <code>nodes</code> are compiled into a
sequence of bytes (omitted for now). Then the pointer to the sequence of
bytes is grabbed, the Rust compiler is instructed to not drop it, and
finally the pointer is returned. The logic is again pretty
straightforward.</p>
<p>Now, let&#39;s focus on the AST to the sequence of bytes (<code>u8</code>) compilation.
All data the AST hold are already bytes, which makes the process easier.
The goal is only to flatten the AST:</p>
<ul>
<li>The first 4 bytes represent the number of nodes at the first level (4
√ó <code>u8</code> represents <code>u32</code>) ,</li>
<li>Next, if the node is <code>Block</code>:
<ul>
<li>The first byte is the node type: <code>1u8</code> for a block,</li>
<li>The second byte is the size of the block name,</li>
<li>The third to the sixth bytes are the size of the attributes,</li>
<li>The seventh byte is the number of node children the block has,</li>
<li>Next bytes are the block name,</li>
<li>Next bytes are the attributes (<code>&amp;b"null"[..]</code> if none),</li>
<li>Next bytes are node children as a sequence of bytes,</li>
</ul>
</li>
<li>Next, if the node is <code>Phrase</code>:
<ul>
<li>The first byte is the node type: <code>2u8</code> for a phrase,</li>
<li>The second to the fifth bytes are the size of the phrase,</li>
<li>Next bytes are the phrase.</li>
</ul>
</li>
</ul>
<p>Here is the missing part of the <code>root</code> function:</p>
<pre class="giallo z-code"><code data-lang="rust"><span class="giallo-l"><span class="z-keyword">if</span><span class="z-storage"> let</span><span class="z-entity z-name"> Ok</span><span>((</span><span class="z-variable">_remaining</span><span>,</span><span class="z-variable"> nodes</span><span>))</span><span class="z-keyword z-operator"> =</span><span class="z-entity z-name"> gutenberg_post_parser</span><span class="z-keyword z-operator">::</span><span class="z-entity z-name z-function">root</span><span>(</span><span class="z-variable">input</span><span>) {</span></span>
<span class="giallo-l"><span class="z-storage">    let</span><span class="z-variable"> nodes_length</span><span class="z-keyword z-operator"> =</span><span class="z-entity z-name z-function"> u32_to_u8s</span><span>(</span><span class="z-variable">nodes</span><span class="z-keyword z-operator">.</span><span class="z-entity z-name z-function">len</span><span>()</span><span class="z-keyword"> as</span><span class="z-entity z-name"> u32</span><span>);</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span class="z-variable">    output</span><span class="z-keyword z-operator">.</span><span class="z-entity z-name z-function">push</span><span>(</span><span class="z-variable">nodes_length</span><span class="z-keyword z-operator">.</span><span class="z-constant z-numeric">0</span><span>);</span></span>
<span class="giallo-l"><span class="z-variable">    output</span><span class="z-keyword z-operator">.</span><span class="z-entity z-name z-function">push</span><span>(</span><span class="z-variable">nodes_length</span><span class="z-keyword z-operator">.</span><span class="z-constant z-numeric">1</span><span>);</span></span>
<span class="giallo-l"><span class="z-variable">    output</span><span class="z-keyword z-operator">.</span><span class="z-entity z-name z-function">push</span><span>(</span><span class="z-variable">nodes_length</span><span class="z-keyword z-operator">.</span><span class="z-constant z-numeric">2</span><span>);</span></span>
<span class="giallo-l"><span class="z-variable">    output</span><span class="z-keyword z-operator">.</span><span class="z-entity z-name z-function">push</span><span>(</span><span class="z-variable">nodes_length</span><span class="z-keyword z-operator">.</span><span class="z-constant z-numeric">3</span><span>);</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span class="z-keyword">    for</span><span class="z-variable"> node</span><span class="z-keyword"> in</span><span class="z-variable"> nodes</span><span> {</span></span>
<span class="giallo-l"><span class="z-entity z-name z-function">        into_bytes</span><span>(</span><span class="z-keyword z-operator">&amp;</span><span class="z-variable">node</span><span>,</span><span class="z-keyword z-operator"> &amp;</span><span class="z-storage">mut</span><span class="z-variable"> output</span><span>);</span></span>
<span class="giallo-l"><span>    }</span></span>
<span class="giallo-l"><span>}</span></span></code></pre>
<p>And here is the <code>into_bytes</code> function:</p>
<pre class="giallo z-code"><code data-lang="rust"><span class="giallo-l"><span class="z-keyword">fn</span><span class="z-entity z-name z-function"> into_bytes</span><span>&lt;&#39;</span><span class="z-entity z-name">a</span><span>&gt;(</span><span class="z-variable">node</span><span class="z-keyword z-operator">: &amp;</span><span class="z-entity z-name">Node</span><span>&lt;&#39;</span><span class="z-entity z-name">a</span><span>&gt;,</span><span class="z-variable"> output</span><span class="z-keyword z-operator">: &amp;</span><span class="z-storage">mut</span><span class="z-entity z-name"> Vec</span><span>&lt;</span><span class="z-entity z-name">u8</span><span>&gt;) {</span></span>
<span class="giallo-l"><span class="z-keyword">    match</span><span class="z-keyword z-operator"> *</span><span class="z-variable">node</span><span> {</span></span>
<span class="giallo-l"><span class="z-entity z-name">¬†       Node</span><span class="z-keyword z-operator">::</span><span class="z-entity z-name">Block</span><span> {</span><span class="z-variable"> name</span><span>,</span><span class="z-variable"> attributes</span><span>,</span><span class="z-keyword"> ref</span><span class="z-variable"> children</span><span> }</span><span class="z-keyword z-operator"> =&gt;</span><span> {</span></span>
<span class="giallo-l"><span class="z-storage">          ¬† let</span><span class="z-variable"> node_type</span><span class="z-keyword z-operator"> =</span><span class="z-constant z-numeric"> 1</span><span class="z-entity z-name">u8</span><span>;</span></span>
<span class="giallo-l"><span class="z-storage">¬†           let</span><span class="z-variable"> name_length</span><span class="z-keyword z-operator"> =</span><span class="z-variable"> name</span><span class="z-keyword z-operator">.</span><span class="z-constant z-numeric">0</span><span class="z-punctuation z-separator">.</span><span class="z-entity z-name z-function">len</span><span>()</span><span class="z-keyword z-operator"> +</span><span class="z-variable"> name</span><span class="z-keyword z-operator">.</span><span class="z-constant z-numeric">1</span><span class="z-punctuation z-separator">.</span><span class="z-entity z-name z-function">len</span><span>()</span><span class="z-keyword z-operator"> +</span><span class="z-constant z-numeric"> 1</span><span>;</span></span>
<span class="giallo-l"><span class="z-storage">          ¬† let</span><span class="z-variable"> attributes_length</span><span class="z-keyword z-operator"> =</span><span class="z-keyword"> match</span><span class="z-variable"> attributes</span><span> {</span></span>
<span class="giallo-l"><span class="z-entity z-name">              ¬† Some</span><span>(</span><span class="z-variable">attributes</span><span>)</span><span class="z-keyword z-operator"> =&gt;</span><span class="z-variable"> attributes</span><span class="z-keyword z-operator">.</span><span class="z-entity z-name z-function">len</span><span>(),</span></span>
<span class="giallo-l"><span class="z-entity z-name">              ¬† None</span><span class="z-keyword z-operator"> =&gt;</span><span class="z-constant z-numeric"> 4</span></span>
<span class="giallo-l"><span>          ¬† };</span></span>
<span class="giallo-l"><span class="z-storage">          ¬† let</span><span class="z-variable"> attributes_length_as_u8s</span><span class="z-keyword z-operator"> =</span><span class="z-entity z-name z-function"> u32_to_u8s</span><span>(</span><span class="z-variable">attributes_length</span><span class="z-keyword"> as</span><span class="z-entity z-name"> u32</span><span>);</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span class="z-storage">          ¬† let</span><span class="z-variable"> number_of_children</span><span class="z-keyword z-operator"> =</span><span class="z-variable"> children</span><span class="z-keyword z-operator">.</span><span class="z-entity z-name z-function">len</span><span>();</span></span>
<span class="giallo-l"><span class="z-variable">¬†           output</span><span class="z-keyword z-operator">.</span><span class="z-entity z-name z-function">push</span><span>(</span><span class="z-variable">node_type</span><span>);</span></span>
<span class="giallo-l"><span class="z-variable">          ¬† output</span><span class="z-keyword z-operator">.</span><span class="z-entity z-name z-function">push</span><span>(</span><span class="z-variable">name_length</span><span class="z-keyword"> as</span><span class="z-entity z-name"> u8</span><span>);</span></span>
<span class="giallo-l"><span class="z-variable">          ¬† output</span><span class="z-keyword z-operator">.</span><span class="z-entity z-name z-function">push</span><span>(</span><span class="z-variable">attributes_length_as_u8s</span><span class="z-keyword z-operator">.</span><span class="z-constant z-numeric">0</span><span>);</span></span>
<span class="giallo-l"><span class="z-variable">          ¬† output</span><span class="z-keyword z-operator">.</span><span class="z-entity z-name z-function">push</span><span>(</span><span class="z-variable">attributes_length_as_u8s</span><span class="z-keyword z-operator">.</span><span class="z-constant z-numeric">1</span><span>);</span></span>
<span class="giallo-l"><span class="z-variable">          ¬† output</span><span class="z-keyword z-operator">.</span><span class="z-entity z-name z-function">push</span><span>(</span><span class="z-variable">attributes_length_as_u8s</span><span class="z-keyword z-operator">.</span><span class="z-constant z-numeric">2</span><span>);</span></span>
<span class="giallo-l"><span class="z-variable">          ¬† output</span><span class="z-keyword z-operator">.</span><span class="z-entity z-name z-function">push</span><span>(</span><span class="z-variable">attributes_length_as_u8s</span><span class="z-keyword z-operator">.</span><span class="z-constant z-numeric">3</span><span>);</span></span>
<span class="giallo-l"><span class="z-variable">          ¬† output</span><span class="z-keyword z-operator">.</span><span class="z-entity z-name z-function">push</span><span>(</span><span class="z-variable">number_of_children</span><span class="z-keyword"> as</span><span class="z-entity z-name"> u8</span><span>);</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span class="z-variable">          ¬† output</span><span class="z-keyword z-operator">.</span><span class="z-entity z-name z-function">extend</span><span>(</span><span class="z-variable">name</span><span class="z-keyword z-operator">.</span><span class="z-constant z-numeric">0</span><span>);</span></span>
<span class="giallo-l"><span class="z-variable">          ¬† output</span><span class="z-keyword z-operator">.</span><span class="z-entity z-name z-function">push</span><span>(</span><span class="z-string">b&#39;/&#39;</span><span>);</span></span>
<span class="giallo-l"><span class="z-variable">          ¬† output</span><span class="z-keyword z-operator">.</span><span class="z-entity z-name z-function">extend</span><span>(</span><span class="z-variable">name</span><span class="z-keyword z-operator">.</span><span class="z-constant z-numeric">1</span><span>);</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span class="z-keyword">          ¬† if</span><span class="z-storage"> let</span><span class="z-entity z-name"> Some</span><span>(</span><span class="z-variable">attributes</span><span>)</span><span class="z-keyword z-operator"> =</span><span class="z-variable"> attributes</span><span> {</span></span>
<span class="giallo-l"><span class="z-variable">              ¬† output</span><span class="z-keyword z-operator">.</span><span class="z-entity z-name z-function">extend</span><span>(</span><span class="z-variable">attributes</span><span>);</span></span>
<span class="giallo-l"><span>           ¬†}</span><span class="z-keyword"> else</span><span> {</span></span>
<span class="giallo-l"><span class="z-variable">              ¬† output</span><span class="z-keyword z-operator">.</span><span class="z-entity z-name z-function">extend</span><span>(</span><span class="z-keyword z-operator">&amp;</span><span class="z-string">b&quot;null&quot;</span><span>[</span><span class="z-keyword z-operator">..</span><span>]);</span></span>
<span class="giallo-l"><span>            }</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span class="z-keyword">          ¬† for</span><span class="z-variable"> child</span><span class="z-keyword"> in</span><span class="z-variable"> children</span><span> {</span></span>
<span class="giallo-l"><span class="z-entity z-name z-function">          ¬†     into_bytes</span><span>(</span><span class="z-keyword z-operator">&amp;</span><span class="z-variable">child</span><span>,</span><span class="z-variable"> output</span><span>);</span></span>
<span class="giallo-l"><span>            }</span></span>
<span class="giallo-l"><span>        },</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span class="z-entity z-name">        Node</span><span class="z-keyword z-operator">::</span><span class="z-entity z-name z-function">Phrase</span><span>(</span><span class="z-variable">phrase</span><span>)</span><span class="z-keyword z-operator"> =&gt;</span><span> {</span></span>
<span class="giallo-l"><span class="z-storage">          ¬† let</span><span class="z-variable"> node_type</span><span class="z-keyword z-operator"> =</span><span class="z-constant z-numeric"> 2</span><span class="z-entity z-name">u8</span><span>;</span></span>
<span class="giallo-l"><span class="z-storage">          ¬† let</span><span class="z-variable"> phrase_length</span><span class="z-keyword z-operator"> =</span><span class="z-variable"> phrase</span><span class="z-keyword z-operator">.</span><span class="z-entity z-name z-function">len</span><span>();</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span class="z-variable">          ¬† output</span><span class="z-keyword z-operator">.</span><span class="z-entity z-name z-function">push</span><span>(</span><span class="z-variable">node_type</span><span>);</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span class="z-storage">          ¬† let</span><span class="z-variable"> phrase_length_as_u8s</span><span class="z-keyword z-operator"> =</span><span class="z-entity z-name z-function"> u32_to_u8s</span><span>(</span><span class="z-variable">phrase_length</span><span class="z-keyword"> as</span><span class="z-entity z-name"> u32</span><span>);</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span class="z-variable">          ¬† output</span><span class="z-keyword z-operator">.</span><span class="z-entity z-name z-function">push</span><span>(</span><span class="z-variable">phrase_length_as_u8s</span><span class="z-keyword z-operator">.</span><span class="z-constant z-numeric">0</span><span>);</span></span>
<span class="giallo-l"><span class="z-variable">          ¬† output</span><span class="z-keyword z-operator">.</span><span class="z-entity z-name z-function">push</span><span>(</span><span class="z-variable">phrase_length_as_u8s</span><span class="z-keyword z-operator">.</span><span class="z-constant z-numeric">1</span><span>);</span></span>
<span class="giallo-l"><span class="z-variable">          ¬† output</span><span class="z-keyword z-operator">.</span><span class="z-entity z-name z-function">push</span><span>(</span><span class="z-variable">phrase_length_as_u8s</span><span class="z-keyword z-operator">.</span><span class="z-constant z-numeric">2</span><span>);</span></span>
<span class="giallo-l"><span class="z-variable">            output</span><span class="z-keyword z-operator">.</span><span class="z-entity z-name z-function">push</span><span>(</span><span class="z-variable">phrase_length_as_u8s</span><span class="z-keyword z-operator">.</span><span class="z-constant z-numeric">3</span><span>);</span></span>
<span class="giallo-l"><span class="z-variable">          ¬† output</span><span class="z-keyword z-operator">.</span><span class="z-entity z-name z-function">extend</span><span>(</span><span class="z-variable">phrase</span><span>);</span></span>
<span class="giallo-l"><span>        }</span></span>
<span class="giallo-l"><span>    }</span></span>
<span class="giallo-l"><span>}</span></span></code></pre>
<p>What I find interesting with this code is it reads just like the bullet
list above the code.</p>
<p>For the most curious, here is the <code>u32_to_u8s</code> function:</p>
<pre class="giallo z-code"><code data-lang="rust"><span class="giallo-l"><span class="z-keyword">fn</span><span class="z-entity z-name z-function"> u32_to_u8s</span><span>(</span><span class="z-variable">x</span><span class="z-keyword z-operator">:</span><span class="z-entity z-name"> u32</span><span>)</span><span class="z-keyword z-operator"> -&gt;</span><span> (</span><span class="z-entity z-name">u8</span><span>,</span><span class="z-entity z-name"> u8</span><span>,</span><span class="z-entity z-name"> u8</span><span>,</span><span class="z-entity z-name"> u8</span><span>) {</span></span>
<span class="giallo-l"><span>    (</span></span>
<span class="giallo-l"><span>        ((</span><span class="z-variable">x</span><span class="z-keyword z-operator"> &gt;&gt;</span><span class="z-constant z-numeric"> 24</span><span>)</span><span class="z-keyword z-operator"> &amp;</span><span class="z-constant z-numeric"> 0xff</span><span>)</span><span class="z-keyword"> as</span><span class="z-entity z-name"> u8</span><span>,</span></span>
<span class="giallo-l"><span>        ((</span><span class="z-variable">x</span><span class="z-keyword z-operator"> &gt;&gt;</span><span class="z-constant z-numeric"> 16</span><span>)</span><span class="z-keyword z-operator"> &amp;</span><span class="z-constant z-numeric"> 0xff</span><span>)</span><span class="z-keyword"> as</span><span class="z-entity z-name"> u8</span><span>,</span></span>
<span class="giallo-l"><span>        ((</span><span class="z-variable">x</span><span class="z-keyword z-operator"> &gt;&gt;</span><span class="z-constant z-numeric"> 8</span><span>)</span><span class="z-keyword z-operator">  &amp;</span><span class="z-constant z-numeric"> 0xff</span><span>)</span><span class="z-keyword"> as</span><span class="z-entity z-name"> u8</span><span>,</span></span>
<span class="giallo-l"><span>        (</span><span class="z-variable"> x</span><span class="z-keyword z-operator">        &amp;</span><span class="z-constant z-numeric"> 0xff</span><span>)</span><span class="z-keyword"> as</span><span class="z-entity z-name"> u8</span></span>
<span class="giallo-l"><span>    )</span></span>
<span class="giallo-l"><span>}</span></span></code></pre>
<p>Here we are. <code>alloc</code>, <code>dealloc</code>, <code>root</code>, and <code>into_bytes</code>. Four
functions, and everything is done.</p>
<h3 id="-3">Producing and optimising the WebAssembly binary<a role="presentation" class="anchor" href="#-3" title="Anchor link to this header">#</a>
</h3>
<p>To get a WebAssembly binary, the project has to be compiled to the
<code>wasm32-unknown-unknown</code> target. For now (and it will change in a near
future), the nightly toolchain is needed to compile the project, so make
sure you have the latest nightly version of <code>rustc</code> &amp; co. installed with
<code>rustup update nightly</code>. Let&#39;s run <code>cargo</code>:</p>
<pre class="giallo z-code"><code data-lang="shellsession"><span class="giallo-l"><span class="z-punctuation z-separator">$</span><span class="z-variable"> RUSTFLAGS</span><span class="z-keyword z-operator">=</span><span class="z-string">&#39;-g&#39;</span><span class="z-entity z-name"> cargo</span><span class="z-string"> +nightly build</span><span class="z-constant z-other"> --target</span><span class="z-string"> wasm32-unknown-unknown</span><span class="z-constant z-other"> --release</span></span></code></pre>
<p>The WebAssembly binary weights 22kb. Our goal is to reduce the file
size. For that, the following tools will be required:</p>
<ul>
<li><a rel="noopener external" target="_blank" href="https://github.com/alexcrichton/wasm-gc"><code>wasm-gc</code></a> to garbage-collect unused
imports, internal functions, types etc.,</li>
<li><a rel="noopener external" target="_blank" href="https://github.com/rustwasm/wasm-snip"><code>wasm-snip</code></a> to mark some functions as
unreachable, this is useful when the binary includes unused code that the
linker were not able to remove,</li>
<li><code>wasm-opt</code> from the <a rel="noopener external" target="_blank" href="https://github.com/WebAssembly/binaryen">Binaryen
project</a>, to optimise the
binary,</li>
<li><a rel="noopener external" target="_blank" href="http://www.gzip.org/"><code>gzip</code></a> and
<a rel="noopener external" target="_blank" href="https://github.com/google/brotli"><code>brotli</code></a> to compress the binary.</li>
</ul>
<p>Basically, what we do is the following:</p>
<pre class="giallo z-code"><code data-lang="shellsession"><span class="giallo-l"><span class="z-punctuation z-separator">$</span><span> # Garbage-collect unused data.</span></span>
<span class="giallo-l"><span class="z-punctuation z-separator">$</span><span> wasm-gc gutenberg_post_parser.wasm</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span class="z-punctuation z-separator">$</span><span> # Mark fmt and panicking as unreachable.</span></span>
<span class="giallo-l"><span class="z-punctuation z-separator">$</span><span> wasm-snip --snip-rust-fmt-code --snip-rust-panicking-code gutenberg_post_parser.wasm -o gutenberg_post_parser_snipped.wasm</span></span>
<span class="giallo-l"><span class="z-punctuation z-separator">$</span><span> mv gutenberg_post_parser_snipped.wasm gutenberg_post_parser.wasm</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span class="z-punctuation z-separator">$</span><span> # Garbage-collect unreachable data.</span></span>
<span class="giallo-l"><span class="z-punctuation z-separator">$</span><span> wasm-gc gutenberg_post_parser.wasm</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span class="z-punctuation z-separator">$</span><span> # Optimise </span><span class="z-keyword">for</span><span> small size.</span></span>
<span class="giallo-l"><span class="z-punctuation z-separator">$</span><span> wasm-opt -Oz -o gutenberg_post_parser_opt.wasm gutenberg_post_parser.wasm</span></span>
<span class="giallo-l"><span class="z-punctuation z-separator">$</span><span> mv gutenberg_post_parser_opt.wasm gutenberg_post_parser.wasm</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span class="z-punctuation z-separator">$</span><span> # Compress.</span></span>
<span class="giallo-l"><span class="z-punctuation z-separator">$</span><span> gzip --best --stdout gutenberg_post_parser.wasm </span><span class="z-keyword z-operator">&gt;</span><span> gutenberg_post_parser.wasm.gz</span></span>
<span class="giallo-l"><span class="z-punctuation z-separator">$</span><span> brotli --best --stdout</span><span class="z-variable"> --lgwin</span><span class="z-keyword z-operator">=</span><span class="z-string">24</span><span class="z-entity z-name"> gutenberg_post_parser.wasm</span><span class="z-keyword z-operator"> &gt;</span><span class="z-string"> gutenberg_post_parser.wasm.br</span><span> </span></span></code></pre>
<p>We end up with the following file sizes:</p>
<ul>
<li><code>.wasm</code>: 16kb,</li>
<li><code>.wasm.gz</code>: 7.3kb,</li>
<li><code>.wasm.br</code>: 6.2kb.</li>
</ul>
<p>Neat! <a rel="noopener external" target="_blank" href="https://caniuse.com/#search=brotli">Brotli is implemented by most
browsers</a>, so when the client sends
<code>Accept-Encoding: br</code>, the server can response with the <code>.wasm.br</code> file.</p>
<p>To give you a feeling of what 6.2kb represent, the following image also
weights 6.2kb:</p>
<figure>
<p><img src="https://mnt.io/series/from-rust-to-beyond/the-webassembly-galaxy/./image-example.png" alt="The WordPress&#39;s logo" loading="lazy" decoding="async" /></p>
  <figcaption>
<p>An image that is as weight as our compressed WebAssembly module.</p>
  </figcaption>
</figure>
<p>The WebAssembly binary is ready to run!</p>
<h2 id="-4">WebAssembly üöÄ Javascript<a role="presentation" class="anchor" href="#-4" title="Anchor link to this header">#</a>
</h2>
<figure role="presentation">
<p><img src="https://mnt.io/series/from-rust-to-beyond/the-webassembly-galaxy/./wasm-to-js.png" alt="Wasm to JS" loading="lazy" decoding="async" /></p>
</figure>
<p>In this section, we assume Javascript runs in a browser. Thus, what we
need to do is the following:</p>
<ol>
<li>Load/stream and instanciate the WebAssembly binary,</li>
<li>Write the blog post to parse in the WebAssembly module memory,</li>
<li>Call the <code>root</code> function on the parser,</li>
<li>Read the WebAssembly module memory to load the flat AST (a sequence of bytes)
and decode it to build a ‚ÄúJavascript AST‚Äù (with our own objects).</li>
</ol>
<p><a rel="noopener external" target="_blank" href="https://github.com/Hywan/gutenberg-parser-rs/blob/master/bindings/wasm/bin/gutenberg_post_parser.mjs">The entire code lands
here</a>.
It is approximately 150 lines of code too. I won&#39;t explain the whole
code since some parts of it is the ‚Äúfriendly API‚Äù that is exposed to the
user. So I will rather explain the major pieces.</p>
<h3 id="-5">Loading/streaming and instanciating<a role="presentation" class="anchor" href="#-5" title="Anchor link to this header">#</a>
</h3>
<p><a rel="noopener external" target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly">The <code>WebAssembly</code>
API</a>
exposes multiple ways to load a WebAssembly binary. The best you can use
is <a rel="noopener external" target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/instantiateStreaming">the <code>WebAssembly.instanciateStreaming</code>
function</a>:
It streams the binary and compiles it in the same time, nothing is
blocking. This API relies on <a rel="noopener external" target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API">the <code>Fetch</code>
API</a>. You
might have guessed it: It is asynchronous (it returns a promise).
WebAssembly itself is not asynchronous (except if you use thread), but
the instanciation step is. It is possible to avoid that, but this is
tricky, and Google Chrome has a strong limit of 4kb for the binary size
which will make you give up quickly.</p>
<p>To be able to stream the WebAssembly binary, the server must send the
<code>application/wasm</code> MIME type (with the <code>Content-Type</code> header).</p>
<p>Let&#39;s instanciate our WebAssembly:</p>
<pre class="giallo z-code"><code data-lang="javascript"><span class="giallo-l"><span class="z-storage">const</span><span class="z-variable"> url</span><span class="z-keyword z-operator"> =</span><span class="z-string"> &#39;/gutenberg_post_parser.wasm&#39;</span><span class="z-punctuation z-terminator">;</span></span>
<span class="giallo-l"><span class="z-storage">const</span><span class="z-variable"> wasm</span><span class="z-keyword z-operator"> =</span></span>
<span class="giallo-l"><span class="z-variable">    WebAssembly</span><span class="z-punctuation z-accessor">.</span></span>
<span class="giallo-l"><span class="z-entity z-name z-function">        instantiateStreaming</span><span>(</span><span class="z-entity z-name z-function">fetch</span><span>(</span><span class="z-variable">url</span><span>)</span><span class="z-punctuation z-separator">,</span><span> {})</span><span class="z-punctuation z-accessor">.</span></span>
<span class="giallo-l"><span class="z-entity z-name z-function">        then</span><span>(</span><span class="z-variable z-parameter">object</span><span class="z-storage z-type z-function"> =&gt;</span><span class="z-variable"> object</span><span class="z-punctuation z-accessor">.</span><span class="z-variable">instance</span><span>)</span><span class="z-punctuation z-accessor">.</span></span>
<span class="giallo-l"><span class="z-entity z-name z-function">        then</span><span>(</span><span class="z-variable z-parameter">instance</span><span class="z-storage z-type z-function"> =&gt;</span><span> {</span><span class="z-comment"> /* step 2 */</span><span> })</span><span class="z-punctuation z-terminator">;</span></span></code></pre>
<p>The WebAssembly binary has been instanciated! Now we can move to the
next step.</p>
<h3 id="-6">Last polish before running the parser<a role="presentation" class="anchor" href="#-6" title="Anchor link to this header">#</a>
</h3>
<p>Remember that the WebAssembly binary exports 3 functions: <code>alloc</code>,
<code>dealloc</code>, and <code>root</code>. They can be found on the <code>exports</code> property,
along with the memory. Let&#39;s write that:</p>
<pre class="giallo z-code"><code data-lang="javascript"><span class="giallo-l"><span class="z-entity z-name z-function">¬†       then</span><span>(</span><span class="z-variable z-parameter">instance</span><span class="z-storage z-type z-function"> =&gt;</span><span> {</span></span>
<span class="giallo-l"><span class="z-storage">            const</span><span class="z-variable"> Module</span><span class="z-keyword z-operator"> =</span><span> {</span></span>
<span class="giallo-l"><span>                alloc</span><span class="z-punctuation z-separator">:</span><span class="z-variable"> instance</span><span class="z-punctuation z-accessor">.</span><span class="z-variable">exports</span><span class="z-punctuation z-accessor">.</span><span class="z-variable">alloc</span><span class="z-punctuation z-separator">,</span></span>
<span class="giallo-l"><span>                dealloc</span><span class="z-punctuation z-separator">:</span><span class="z-variable"> instance</span><span class="z-punctuation z-accessor">.</span><span class="z-variable">exports</span><span class="z-punctuation z-accessor">.</span><span class="z-variable">dealloc</span><span class="z-punctuation z-separator">,</span></span>
<span class="giallo-l"><span>                root</span><span class="z-punctuation z-separator">:</span><span class="z-variable"> instance</span><span class="z-punctuation z-accessor">.</span><span class="z-variable">exports</span><span class="z-punctuation z-accessor">.</span><span class="z-variable">root</span><span class="z-punctuation z-separator">,</span></span>
<span class="giallo-l"><span>                memory</span><span class="z-punctuation z-separator">:</span><span class="z-variable"> instance</span><span class="z-punctuation z-accessor">.</span><span class="z-variable">exports</span><span class="z-punctuation z-accessor">.</span><span class="z-variable">memory</span></span>
<span class="giallo-l"><span>            }</span><span class="z-punctuation z-terminator">;</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span class="z-entity z-name z-function">            runParser</span><span>(</span><span class="z-variable">Module</span><span class="z-punctuation z-separator">,</span><span class="z-string"> &#39;&lt;!-- wp:foo /--&gt;xyz&#39;</span><span>)</span><span class="z-punctuation z-terminator">;</span></span>
<span class="giallo-l"><span>        })</span><span class="z-punctuation z-terminator">;</span></span></code></pre>
<p>Great, everything is ready to write the <code>runParser</code> function!</p>
<h3 id="-7">The parser runner<a role="presentation" class="anchor" href="#-7" title="Anchor link to this header">#</a>
</h3>
<p>As a reminder, this function has to: Write the <code>input</code> (the blog post to
parse) in the WebAssembly module memory (<code>Module.memory</code>), to call the
<code>root</code> function (<code>Module.root</code>), and to read the result from the
WebAssembly module memory. Let&#39;s do that:</p>
<pre class="giallo z-code"><code data-lang="javascript"><span class="giallo-l"><span class="z-storage z-type z-function">function</span><span class="z-entity z-name z-function"> runParser</span><span>(</span><span class="z-variable z-parameter">Module</span><span class="z-punctuation z-separator">,</span><span class="z-variable z-parameter"> raw_input</span><span>) {</span></span>
<span class="giallo-l"><span class="z-storage">    const</span><span class="z-variable"> input</span><span class="z-keyword z-operator"> = new</span><span class="z-entity z-name z-function"> TextEncoder</span><span>()</span><span class="z-punctuation z-accessor">.</span><span class="z-entity z-name z-function">encode</span><span>(</span><span class="z-variable">raw_input</span><span>)</span><span class="z-punctuation z-terminator">;</span></span>
<span class="giallo-l"><span class="z-storage">    const</span><span class="z-variable"> input_pointer</span><span class="z-keyword z-operator"> =</span><span class="z-entity z-name z-function"> writeBuffer</span><span>(</span><span class="z-variable">Module</span><span class="z-punctuation z-separator">,</span><span class="z-variable"> input</span><span>)</span><span class="z-punctuation z-terminator">;</span></span>
<span class="giallo-l"><span class="z-storage">    const</span><span class="z-variable"> output_pointer</span><span class="z-keyword z-operator"> =</span><span class="z-variable"> Module</span><span class="z-punctuation z-accessor">.</span><span class="z-entity z-name z-function">root</span><span>(</span><span class="z-variable">input_pointer</span><span class="z-punctuation z-separator">,</span><span class="z-variable"> input</span><span class="z-punctuation z-accessor">.</span><span>length)</span><span class="z-punctuation z-terminator">;</span></span>
<span class="giallo-l"><span class="z-storage">    const</span><span class="z-variable"> result</span><span class="z-keyword z-operator"> =</span><span class="z-entity z-name z-function"> readNodes</span><span>(</span><span class="z-variable">Module</span><span class="z-punctuation z-separator">,</span><span class="z-variable"> output_pointer</span><span>)</span><span class="z-punctuation z-terminator">;</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span class="z-variable">    Module</span><span class="z-punctuation z-accessor">.</span><span class="z-entity z-name z-function">dealloc</span><span>(</span><span class="z-variable">input_pointer</span><span class="z-punctuation z-separator">,</span><span class="z-variable"> input</span><span class="z-punctuation z-accessor">.</span><span>length)</span><span class="z-punctuation z-terminator">;</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span class="z-keyword">    return</span><span class="z-variable"> result</span><span class="z-punctuation z-terminator">;</span></span>
<span class="giallo-l"><span>}</span></span></code></pre>
<p>In details:</p>
<ul>
<li>The <code>raw_input</code> is encoded into a sequence of bytes with <a rel="noopener external" target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/API/TextEncoder">the
<code>TextEncoder</code>API</a>,
in <code>input</code>,</li>
<li>The input is written into the WebAssembly memory module with
<code>writeBuffer</code> and its pointer is returned,</li>
<li>Then the <code>root</code> function is called with the pointer to the input and
the length of the input as expected, and the pointer to the output is
returned,</li>
<li>Then the output is decoded,</li>
<li>And finally, the input is deallocated. The output of the parser will
be deallocated in the <code>readNodes</code> function because its length is
unknown at this step.</li>
</ul>
<p>Great! So we have 2 functions to write right now: <code>writeBuffer</code>‚Äã and
<code>readNodes</code>.</p>
<h3 id="-8">Writing the data in memory<a role="presentation" class="anchor" href="#-8" title="Anchor link to this header">#</a>
</h3>
<p>Let&#39;s go with the first one, <code>writeBuffer</code>:</p>
<pre class="giallo z-code"><code data-lang="javascript"><span class="giallo-l"><span class="z-storage z-type z-function">function</span><span class="z-entity z-name z-function"> writeBuffer</span><span>(</span><span class="z-variable z-parameter">Module</span><span class="z-punctuation z-separator">,</span><span class="z-variable z-parameter"> buffer</span><span>) {</span></span>
<span class="giallo-l"><span class="z-storage">    const</span><span class="z-variable"> buffer_length</span><span class="z-keyword z-operator"> =</span><span class="z-variable"> buffer</span><span class="z-punctuation z-accessor">.</span><span>length</span><span class="z-punctuation z-terminator">;</span></span>
<span class="giallo-l"><span class="z-storage">    const</span><span class="z-variable"> pointer</span><span class="z-keyword z-operator"> =</span><span class="z-variable"> Module</span><span class="z-punctuation z-accessor">.</span><span class="z-entity z-name z-function">alloc</span><span>(</span><span class="z-variable">buffer_length</span><span>)</span><span class="z-punctuation z-terminator">;</span></span>
<span class="giallo-l"><span class="z-storage">    const</span><span class="z-variable"> memory</span><span class="z-keyword z-operator"> = new</span><span class="z-entity z-name z-function"> Uint8Array</span><span>(</span><span class="z-variable">Module</span><span class="z-punctuation z-accessor">.</span><span class="z-variable">memory</span><span class="z-punctuation z-accessor">.</span><span class="z-variable">buffer</span><span>)</span><span class="z-punctuation z-terminator">;</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span class="z-keyword">    for</span><span> (</span><span class="z-storage">let</span><span class="z-variable"> i</span><span class="z-keyword z-operator"> =</span><span class="z-constant z-numeric"> 0</span><span class="z-punctuation z-terminator">;</span><span class="z-variable"> i</span><span class="z-keyword z-operator"> &lt;</span><span class="z-variable"> buffer_length</span><span class="z-punctuation z-terminator">;</span><span class="z-keyword z-operator"> ++</span><span class="z-variable">i</span><span>) {</span></span>
<span class="giallo-l"><span class="z-variable">        memory</span><span>[</span><span class="z-variable">pointer</span><span class="z-keyword z-operator"> +</span><span class="z-variable"> i</span><span>]</span><span class="z-keyword z-operator"> =</span><span class="z-variable"> buffer</span><span>[</span><span class="z-variable">i</span><span>]</span><span class="z-punctuation z-terminator">;</span></span>
<span class="giallo-l"><span>    }</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span class="z-keyword">    return</span><span class="z-variable"> pointer</span><span class="z-punctuation z-terminator">;</span></span>
<span class="giallo-l"><span>}</span></span></code></pre>
<p>In details:</p>
<ul>
<li>The length of the buffer is read in <code>buffer_length</code>,</li>
<li>A space in memory is allocated to write the buffer,</li>
<li>Then a <code>uint8</code> view of the buffer is instanciated, which means that
the buffer will be viewed as a sequence of <code>u8</code>, exactly what Rust
expects,</li>
<li>Finally the buffer is copied into the memory with a loop, that&#39;s very
basic, and return the pointer.</li>
</ul>
<p>Note that, unlike C strings, adding a <code>NUL</code> byte at the end is not
mandatory. This is just the raw data (on the Rust side, we read it with
<code>slice::from_raw_parts</code>, slice is a very simple structure).</p>
<h3 id="-9">Reading the output of the parser<a role="presentation" class="anchor" href="#-9" title="Anchor link to this header">#</a>
</h3>
<p>So at this step, the input has been written in memory, and the <code>root</code>
function has been called so it means the parser has run. It has returned
a pointer to the output (the result) and we now have to read it and
decode it.</p>
<p>Remind that the first 4 bytes encodes the number of nodes we have to
read. Let&#39;s go!</p>
<pre class="giallo z-code"><code data-lang="javascript"><span class="giallo-l"><span class="z-storage z-type z-function">function</span><span class="z-entity z-name z-function"> readNodes</span><span>(</span><span class="z-variable z-parameter">Module</span><span class="z-punctuation z-separator">,</span><span class="z-variable z-parameter"> start_pointer</span><span>) {</span></span>
<span class="giallo-l"><span class="z-storage">    const</span><span class="z-variable"> buffer</span><span class="z-keyword z-operator"> = new</span><span class="z-entity z-name z-function"> Uint8Array</span><span>(</span><span class="z-variable">Module</span><span class="z-punctuation z-accessor">.</span><span class="z-variable">memory</span><span class="z-punctuation z-accessor">.</span><span class="z-variable">buffer</span><span class="z-punctuation z-accessor">.</span><span class="z-entity z-name z-function">slice</span><span>(</span><span class="z-variable">start_pointer</span><span>))</span><span class="z-punctuation z-terminator">;</span></span>
<span class="giallo-l"><span class="z-storage">    const</span><span class="z-variable"> number_of_nodes</span><span class="z-keyword z-operator"> =</span><span class="z-entity z-name z-function"> u8s_to_u32</span><span>(</span><span class="z-variable">buffer</span><span>[</span><span class="z-constant z-numeric">0</span><span>]</span><span class="z-punctuation z-separator">,</span><span class="z-variable"> buffer</span><span>[</span><span class="z-constant z-numeric">1</span><span>]</span><span class="z-punctuation z-separator">,</span><span class="z-variable"> buffer</span><span>[</span><span class="z-constant z-numeric">2</span><span>]</span><span class="z-punctuation z-separator">,</span><span class="z-variable"> buffer</span><span>[</span><span class="z-constant z-numeric">3</span><span>])</span><span class="z-punctuation z-terminator">;</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span class="z-keyword">    if</span><span> (</span><span class="z-constant z-numeric">0</span><span class="z-keyword z-operator"> &gt;=</span><span class="z-variable"> number_of_nodes</span><span>) {</span></span>
<span class="giallo-l"><span class="z-keyword">        return</span><span class="z-constant z-language"> null</span><span class="z-punctuation z-terminator">;</span></span>
<span class="giallo-l"><span>    }</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span class="z-storage">    const</span><span class="z-variable"> nodes</span><span class="z-keyword z-operator"> =</span><span> []</span><span class="z-punctuation z-terminator">;</span></span>
<span class="giallo-l"><span class="z-storage">    let</span><span class="z-variable"> offset</span><span class="z-keyword z-operator"> =</span><span class="z-constant z-numeric"> 4</span><span class="z-punctuation z-terminator">;</span></span>
<span class="giallo-l"><span class="z-storage">    let</span><span class="z-variable"> end_offset</span><span class="z-punctuation z-terminator">;</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span class="z-keyword">    for</span><span> (</span><span class="z-storage">let</span><span class="z-variable"> i</span><span class="z-keyword z-operator"> =</span><span class="z-constant z-numeric"> 0</span><span class="z-punctuation z-terminator">;</span><span class="z-variable"> i</span><span class="z-keyword z-operator"> &lt;</span><span class="z-variable"> number_of_nodes</span><span class="z-punctuation z-terminator">;</span><span class="z-keyword z-operator"> ++</span><span class="z-variable">i</span><span>) {</span></span>
<span class="giallo-l"><span class="z-storage">        const</span><span class="z-variable"> last_offset</span><span class="z-keyword z-operator"> =</span><span class="z-entity z-name z-function"> readNode</span><span>(</span><span class="z-variable">buffer</span><span class="z-punctuation z-separator">,</span><span class="z-variable"> offset</span><span class="z-punctuation z-separator">,</span><span class="z-variable"> nodes</span><span>)</span><span class="z-punctuation z-terminator">;</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span class="z-variable">        offset</span><span class="z-keyword z-operator"> =</span><span class="z-variable"> end_offset</span><span class="z-keyword z-operator"> =</span><span class="z-variable"> last_offset</span><span class="z-punctuation z-terminator">;</span></span>
<span class="giallo-l"><span>    }</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span class="z-variable">    Module</span><span class="z-punctuation z-accessor">.</span><span class="z-entity z-name z-function">dealloc</span><span>(</span><span class="z-variable">start_pointer</span><span class="z-punctuation z-separator">,</span><span class="z-variable"> start_pointer</span><span class="z-keyword z-operator"> +</span><span class="z-variable"> end_offset</span><span>)</span><span class="z-punctuation z-terminator">;</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span class="z-keyword">    return</span><span class="z-variable"> nodes</span><span class="z-punctuation z-terminator">;</span></span>
<span class="giallo-l"><span>}</span></span></code></pre>
<p>In details:</p>
<ul>
<li>A <code>uint8</code> view of the memory is instanciated‚Ä¶ more precisely: A slice
of the memory starting at <code>start_pointer</code>,</li>
<li>The number of nodes is read, then all nodes are read,</li>
<li>And finally, the output of the parser is deallocated.</li>
</ul>
<p>For the record, here is the <code>u8s_to_u32</code> function, this is the exact
opposite of <code>u32_to_u8s</code>:</p>
<pre class="giallo z-code"><code data-lang="javascript"><span class="giallo-l"><span class="z-storage z-type z-function">function</span><span class="z-entity z-name z-function"> u8s_to_u32</span><span>(</span><span class="z-variable z-parameter">o</span><span class="z-punctuation z-separator">,</span><span class="z-variable z-parameter"> p</span><span class="z-punctuation z-separator">,</span><span class="z-variable z-parameter"> q</span><span class="z-punctuation z-separator">,</span><span class="z-variable z-parameter"> r</span><span>) {</span></span>
<span class="giallo-l"><span class="z-keyword">    return</span><span> (</span><span class="z-variable">o</span><span class="z-keyword z-operator"> &lt;&lt;</span><span class="z-constant z-numeric"> 24</span><span>)</span><span class="z-keyword z-operator"> |</span><span> (</span><span class="z-variable">p</span><span class="z-keyword z-operator"> &lt;&lt;</span><span class="z-constant z-numeric"> 16</span><span>)</span><span class="z-keyword z-operator"> |</span><span> (</span><span class="z-variable">q</span><span class="z-keyword z-operator"> &lt;&lt;</span><span class="z-constant z-numeric"> 8</span><span>)</span><span class="z-keyword z-operator"> |</span><span class="z-variable"> r</span><span class="z-punctuation z-terminator">;</span></span>
<span class="giallo-l"><span>}</span></span></code></pre>
<p>And I will also share the <code>readNode</code> function, but I won&#39;t explain the
details. This is just the decoding part of the output from the parser.</p>
<pre class="giallo z-code"><code data-lang="javascript"><span class="giallo-l"><span class="z-storage z-type z-function">function</span><span class="z-entity z-name z-function"> readNode</span><span>(</span><span class="z-variable z-parameter">buffer</span><span class="z-punctuation z-separator">,</span><span class="z-variable z-parameter"> offset</span><span class="z-punctuation z-separator">,</span><span class="z-variable z-parameter"> nodes</span><span>) {</span></span>
<span class="giallo-l"><span class="z-storage">    const</span><span class="z-variable"> node_type</span><span class="z-keyword z-operator"> =</span><span class="z-variable"> buffer</span><span>[</span><span class="z-variable">offset</span><span>]</span><span class="z-punctuation z-terminator">;</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span class="z-comment">    // Block.</span></span>
<span class="giallo-l"><span class="z-keyword">    if</span><span> (</span><span class="z-constant z-numeric">1</span><span class="z-keyword z-operator"> ===</span><span class="z-variable"> node_type</span><span>) {</span></span>
<span class="giallo-l"><span class="z-storage">        const</span><span class="z-variable"> name_length</span><span class="z-keyword z-operator"> =</span><span class="z-variable"> buffer</span><span>[</span><span class="z-variable">offset</span><span class="z-keyword z-operator"> +</span><span class="z-constant z-numeric"> 1</span><span>]</span><span class="z-punctuation z-terminator">;</span></span>
<span class="giallo-l"><span class="z-storage">        const</span><span class="z-variable"> attributes_length</span><span class="z-keyword z-operator"> =</span><span class="z-entity z-name z-function"> u8s_to_u32</span><span>(</span><span class="z-variable">buffer</span><span>[</span><span class="z-variable">offset</span><span class="z-keyword z-operator"> +</span><span class="z-constant z-numeric"> 2</span><span>]</span><span class="z-punctuation z-separator">,</span><span class="z-variable"> buffer</span><span>[</span><span class="z-variable">offset</span><span class="z-keyword z-operator"> +</span><span class="z-constant z-numeric"> 3</span><span>]</span><span class="z-punctuation z-separator">,</span><span class="z-variable"> buffer</span><span>[</span><span class="z-variable">offset</span><span class="z-keyword z-operator"> +</span><span class="z-constant z-numeric"> 4</span><span>]</span><span class="z-punctuation z-separator">,</span><span class="z-variable"> buffer</span><span>[</span><span class="z-variable">offset</span><span class="z-keyword z-operator"> +</span><span class="z-constant z-numeric"> 5</span><span>])</span><span class="z-punctuation z-terminator">;</span></span>
<span class="giallo-l"><span class="z-storage">        const</span><span class="z-variable"> number_of_children</span><span class="z-keyword z-operator"> =</span><span class="z-variable"> buffer</span><span>[</span><span class="z-variable">offset</span><span class="z-keyword z-operator"> +</span><span class="z-constant z-numeric"> 6</span><span>]</span><span class="z-punctuation z-terminator">;</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span class="z-storage">        let</span><span class="z-variable"> payload_offset</span><span class="z-keyword z-operator"> =</span><span class="z-variable"> offset</span><span class="z-keyword z-operator"> +</span><span class="z-constant z-numeric"> 7</span><span class="z-punctuation z-terminator">;</span></span>
<span class="giallo-l"><span class="z-storage">        let</span><span class="z-variable"> next_payload_offset</span><span class="z-keyword z-operator"> =</span><span class="z-variable"> payload_offset</span><span class="z-keyword z-operator"> +</span><span class="z-variable"> name_length</span><span class="z-punctuation z-terminator">;</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span class="z-storage">        const</span><span class="z-variable"> name</span><span class="z-keyword z-operator"> = new</span><span class="z-entity z-name z-function"> TextDecoder</span><span>()</span><span class="z-punctuation z-accessor">.</span><span class="z-entity z-name z-function">decode</span><span>(</span><span class="z-variable">buffer</span><span class="z-punctuation z-accessor">.</span><span class="z-entity z-name z-function">slice</span><span>(</span><span class="z-variable">payload_offset</span><span class="z-punctuation z-separator">,</span><span class="z-variable"> next_payload_offset</span><span>))</span><span class="z-punctuation z-terminator">;</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span class="z-variable">        payload_offset</span><span class="z-keyword z-operator"> =</span><span class="z-variable"> next_payload_offset</span><span class="z-punctuation z-terminator">;</span></span>
<span class="giallo-l"><span class="z-variable">        next_payload_offset</span><span class="z-keyword z-operator"> +=</span><span class="z-variable"> attributes_length</span><span class="z-punctuation z-terminator">;</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span class="z-storage">        const</span><span class="z-variable"> attributes</span><span class="z-keyword z-operator"> =</span><span class="z-variable"> JSON</span><span class="z-punctuation z-accessor">.</span><span class="z-entity z-name z-function">parse</span><span>(</span><span class="z-keyword z-operator">new</span><span class="z-entity z-name z-function"> TextDecoder</span><span>()</span><span class="z-punctuation z-accessor">.</span><span class="z-entity z-name z-function">decode</span><span>(</span><span class="z-variable">buffer</span><span class="z-punctuation z-accessor">.</span><span class="z-entity z-name z-function">slice</span><span>(</span><span class="z-variable">payload_offset</span><span class="z-punctuation z-separator">,</span><span class="z-variable"> next_payload_offset</span><span>)))</span><span class="z-punctuation z-terminator">;</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span class="z-variable">        payload_offset</span><span class="z-keyword z-operator"> =</span><span class="z-variable"> next_payload_offset</span><span class="z-punctuation z-terminator">;</span></span>
<span class="giallo-l"><span class="z-storage">        let</span><span class="z-variable"> end_offset</span><span class="z-keyword z-operator"> =</span><span class="z-variable"> payload_offset</span><span class="z-punctuation z-terminator">;</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span class="z-storage">        const</span><span class="z-variable"> children</span><span class="z-keyword z-operator"> =</span><span> []</span><span class="z-punctuation z-terminator">;</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span class="z-keyword">        for</span><span> (</span><span class="z-storage">let</span><span class="z-variable"> i</span><span class="z-keyword z-operator"> =</span><span class="z-constant z-numeric"> 0</span><span class="z-punctuation z-terminator">;</span><span class="z-variable"> i</span><span class="z-keyword z-operator"> &lt;</span><span class="z-variable"> number_of_children</span><span class="z-punctuation z-terminator">;</span><span class="z-keyword z-operator"> ++</span><span class="z-variable">i</span><span>) {</span></span>
<span class="giallo-l"><span class="z-storage">            const</span><span class="z-variable"> last_offset</span><span class="z-keyword z-operator"> =</span><span class="z-entity z-name z-function"> readNode</span><span>(</span><span class="z-variable">buffer</span><span class="z-punctuation z-separator">,</span><span class="z-variable"> payload_offset</span><span class="z-punctuation z-separator">,</span><span class="z-variable"> children</span><span>)</span><span class="z-punctuation z-terminator">;</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span class="z-variable">            payload_offset</span><span class="z-keyword z-operator"> =</span><span class="z-variable"> end_offset</span><span class="z-keyword z-operator"> =</span><span class="z-variable"> last_offset</span><span class="z-punctuation z-terminator">;</span></span>
<span class="giallo-l"><span>        }</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span class="z-variable">        nodes</span><span class="z-punctuation z-accessor">.</span><span class="z-entity z-name z-function">push</span><span>(</span><span class="z-keyword z-operator">new</span><span class="z-entity z-name z-function"> Block</span><span>(</span><span class="z-variable">name</span><span class="z-punctuation z-separator">,</span><span class="z-variable"> attributes</span><span class="z-punctuation z-separator">,</span><span class="z-variable"> children</span><span>))</span><span class="z-punctuation z-terminator">;</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span class="z-keyword">        return</span><span class="z-variable"> end_offset</span><span class="z-punctuation z-terminator">;</span></span>
<span class="giallo-l"><span>    }</span></span>
<span class="giallo-l"><span class="z-comment">    // Phrase.</span></span>
<span class="giallo-l"><span class="z-keyword">    else if</span><span> (</span><span class="z-constant z-numeric">2</span><span class="z-keyword z-operator"> ===</span><span class="z-variable"> node_type</span><span>) {</span></span>
<span class="giallo-l"><span class="z-storage">        const</span><span class="z-variable"> phrase_length</span><span class="z-keyword z-operator"> =</span><span class="z-entity z-name z-function"> u8s_to_u32</span><span>(</span><span class="z-variable">buffer</span><span>[</span><span class="z-variable">offset</span><span class="z-keyword z-operator"> +</span><span class="z-constant z-numeric"> 1</span><span>]</span><span class="z-punctuation z-separator">,</span><span class="z-variable"> buffer</span><span>[</span><span class="z-variable">offset</span><span class="z-keyword z-operator"> +</span><span class="z-constant z-numeric"> 2</span><span>]</span><span class="z-punctuation z-separator">,</span><span class="z-variable"> buffer</span><span>[</span><span class="z-variable">offset</span><span class="z-keyword z-operator"> +</span><span class="z-constant z-numeric"> 3</span><span>]</span><span class="z-punctuation z-separator">,</span><span class="z-variable"> buffer</span><span>[</span><span class="z-variable">offset</span><span class="z-keyword z-operator"> +</span><span class="z-constant z-numeric"> 4</span><span>])</span><span class="z-punctuation z-terminator">;</span></span>
<span class="giallo-l"><span class="z-storage">        const</span><span class="z-variable"> phrase_offset</span><span class="z-keyword z-operator"> =</span><span class="z-variable"> offset</span><span class="z-keyword z-operator"> +</span><span class="z-constant z-numeric"> 5</span><span class="z-punctuation z-terminator">;</span></span>
<span class="giallo-l"><span class="z-storage">        const</span><span class="z-variable"> phrase</span><span class="z-keyword z-operator"> = new</span><span class="z-entity z-name z-function"> TextDecoder</span><span>()</span><span class="z-punctuation z-accessor">.</span><span class="z-entity z-name z-function">decode</span><span>(</span><span class="z-variable">buffer</span><span class="z-punctuation z-accessor">.</span><span class="z-entity z-name z-function">slice</span><span>(</span><span class="z-variable">phrase_offset</span><span class="z-punctuation z-separator">,</span><span class="z-variable"> phrase_offset</span><span class="z-keyword z-operator"> +</span><span class="z-variable"> phrase_length</span><span>))</span><span class="z-punctuation z-terminator">;</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span class="z-variable">        nodes</span><span class="z-punctuation z-accessor">.</span><span class="z-entity z-name z-function">push</span><span>(</span><span class="z-keyword z-operator">new</span><span class="z-entity z-name z-function"> Phrase</span><span>(</span><span class="z-variable">phrase</span><span>))</span><span class="z-punctuation z-terminator">;</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span class="z-keyword">        return</span><span class="z-variable"> phrase_offset</span><span class="z-keyword z-operator"> +</span><span class="z-variable"> phrase_length</span><span class="z-punctuation z-terminator">;</span></span>
<span class="giallo-l"><span>    }</span><span class="z-keyword"> else</span><span> {</span></span>
<span class="giallo-l"><span class="z-variable">        console</span><span class="z-punctuation z-accessor">.</span><span class="z-entity z-name z-function">error</span><span>(</span><span class="z-string">&#39;unknown node type&#39;</span><span class="z-punctuation z-separator">,</span><span class="z-variable"> node_type</span><span>)</span><span class="z-punctuation z-terminator">;</span></span>
<span class="giallo-l"><span>    }</span></span>
<span class="giallo-l"><span>}</span></span></code></pre>
<p>Note that this code is pretty simple and easy to optimise by the
Javascript virtual machine. It is almost important to note that this is
not the original code. The original version is a little more optimised
here and there, but they are very close.</p>
<p>And that&#39;s all! We have successfully read and decoded the output of the
parser! We just need to write the <code>Block</code> and <code>Phrase</code> classes like
this:</p>
<pre class="giallo z-code"><code data-lang="javascript"><span class="giallo-l"><span class="z-storage">class</span><span class="z-entity z-name"> Block</span><span> {</span></span>
<span class="giallo-l"><span class="z-storage">    constructor</span><span>(</span><span class="z-variable z-parameter">name</span><span class="z-punctuation z-separator">,</span><span class="z-variable z-parameter"> attributes</span><span class="z-punctuation z-separator">,</span><span class="z-variable z-parameter"> children</span><span>) {</span></span>
<span class="giallo-l"><span class="z-variable z-language">        this</span><span class="z-punctuation z-accessor">.</span><span class="z-variable">name</span><span class="z-keyword z-operator"> =</span><span class="z-variable"> name</span><span class="z-punctuation z-terminator">;</span></span>
<span class="giallo-l"><span class="z-variable z-language">        this</span><span class="z-punctuation z-accessor">.</span><span class="z-variable">attributes</span><span class="z-keyword z-operator"> =</span><span class="z-variable"> attributes</span><span class="z-punctuation z-terminator">;</span></span>
<span class="giallo-l"><span class="z-variable z-language">        this</span><span class="z-punctuation z-accessor">.</span><span class="z-variable">children</span><span class="z-keyword z-operator"> =</span><span class="z-variable"> children</span><span class="z-punctuation z-terminator">;</span></span>
<span class="giallo-l"><span>    }</span></span>
<span class="giallo-l"><span>}</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span class="z-storage">class</span><span class="z-entity z-name"> Phrase</span><span> {</span></span>
<span class="giallo-l"><span class="z-storage">    constructor</span><span>(</span><span class="z-variable z-parameter">phrase</span><span>) {</span></span>
<span class="giallo-l"><span class="z-variable z-language">        this</span><span class="z-punctuation z-accessor">.</span><span class="z-variable">phrase</span><span class="z-keyword z-operator"> =</span><span class="z-variable"> phrase</span><span class="z-punctuation z-terminator">;</span></span>
<span class="giallo-l"><span>    }</span></span>
<span class="giallo-l"><span>}</span></span></code></pre>
<p>The final output will be an array of those objects. Easy!</p>
<h2 id="-10">WebAssembly üöÄ NodeJS<a role="presentation" class="anchor" href="#-10" title="Anchor link to this header">#</a>
</h2>
<figure role="presentation">
<p><img src="https://mnt.io/series/from-rust-to-beyond/the-webassembly-galaxy/./wasm-to-nodejs.png" alt="Wasm to NodeJS" loading="lazy" decoding="async" /></p>
</figure>
<p>The differences between the Javascript version and the NodeJS version
are few:</p>
<ul>
<li>The <code>Fetch</code> API does not exist in NodeJS, so the WebAssembly binary
has to be instanciated with a buffer directly, like this:
<code>WebAssembly.instantiate(fs.readFileSync(url), {})</code>,</li>
<li>The <code>TextEncoder</code> and <code>TextDecoder</code> objects do not exist as global
objects, they are in <code>util.TextEncoder</code> and <code>util.TextDecoder</code>.</li>
</ul>
<p>In order to share the code between both environments, it is possible to
write the boundary layer (the Javascript code we wrote) in a <code>.mjs</code>
file, aka ECMAScript Module. It allows to write something like
<code>import { Gutenberg_Post_Parser } from './gutenberg_post_parser.mjs'</code>
for example (considering the whole code we wrote before is a class). On
the browser side, the script must be loaded
with<code>&lt;script type="module" src="‚Ä¶" /&gt;</code>, and on the NodeJS side, <code>node</code>
must run with the <code>--experimental-modules</code> flag. I can recommend you
this talk <a rel="noopener external" target="_blank" href="https://www.youtube.com/watch?v=35ZMoH8T-gc&amp;index=4&amp;list=PLOkMRkzDhWGX_4YWI4ZYGbwFPqKnDRudf&amp;t=0s"><em>Please wait‚Ä¶ loading: a tale of two loaders</em> by Myles
Borins</a>
at the JSConf EU 2018 to understand all the story about that.</p>
<p><a rel="noopener external" target="_blank" href="https://github.com/Hywan/gutenberg-parser-rs/blob/master/bindings/wasm/bin/index.mjs">The entire code lands
here</a>.</p>
<h2 id="-11">Conclusion<a role="presentation" class="anchor" href="#-11" title="Anchor link to this header">#</a>
</h2>
<p>We have seen in details how to write a real world parser in Rust, how to
compile it into a WebAssembly binary, and how to use it with Javascript
and with NodeJS.</p>
<p>The parser can be used in a browser with regular Javascript code, or as
a CLI with NodeJS, or on any platforms NodeJS supports.</p>
<p>The Rust part for WebAssembly plus the Javascript part totals 313 lines
of code. This is a tiny surface of code to review and to maintain
compared to writing a Javascript parser from scratch.</p>
<p>Another argument is the safety and performance. Rust is memory safe, we
know that. It is also performant, but is it still true for the
WebAssembly target? The following table shows the benchmark results of
the actual Javascript parser for the Gutenberg project (implemented with
<a rel="noopener external" target="_blank" href="https://pegjs.org/">PEG.js</a>), against this project: The Rust parser as
a WebAssembly binary.</p>
<figure>
<table><thead><tr><th>Document</th><th>Javascript parser (ms)</th><th>Rust parser as a WebAssembly binary (ms)</th><th>speedup</th></tr></thead><tbody>
<tr><td><a rel="noopener external" target="_blank" href="https://raw.githubusercontent.com/dmsnell/gutenberg-document-library/master/library/demo-post.html"><code>demo-post.html</code></a></td><td>13.167</td><td>0.252</td><td>√ó 52</td></tr>
<tr><td><a rel="noopener external" target="_blank" href="https://raw.githubusercontent.com/dmsnell/gutenberg-document-library/master/library/shortcode-shortcomings.html"><code>shortcode-shortcomings.html</code></a></td><td>26.784</td><td>0.271</td><td>√ó 98</td></tr>
<tr><td><a rel="noopener external" target="_blank" href="https://raw.githubusercontent.com/dmsnell/gutenberg-document-library/master/library/redesigning-chrome-desktop.html"><code>redesigning-chrome-desktop.html</code></a></td><td>75.500</td><td>0.918</td><td>√ó 82</td></tr>
<tr><td><a rel="noopener external" target="_blank" href="https://raw.githubusercontent.com/dmsnell/gutenberg-document-library/master/library/web-at-maximum-fps.html"><code>web-at-maximum-fps.html</code></a></td><td>88.118</td><td>0.901</td><td>√ó 98</td></tr>
<tr><td><a rel="noopener external" target="_blank" href="https://raw.githubusercontent.com/dmsnell/gutenberg-document-library/master/library/early-adopting-the-future.html"><code>early-adopting-the-future.html</code></a></td><td>201.011</td><td>3.329</td><td>√ó 60</td></tr>
<tr><td><a rel="noopener external" target="_blank" href="https://raw.githubusercontent.com/dmsnell/gutenberg-document-library/master/library/pygmalian-raw-html.html"><code>pygmalian-raw-html.html</code></a></td><td>311.416</td><td>2.692</td><td>√ó 116</td></tr>
<tr><td><a rel="noopener external" target="_blank" href="https://raw.githubusercontent.com/dmsnell/gutenberg-document-library/master/library/moby-dick-parsed.html"><code>moby-dick-parsed.html</code></a></td><td>2,466.533</td><td>25.14</td><td>√ó 98</td></tr>
</tbody></table>
  <figcaption>
<p>Benchmarks between Javascript parser and Rust parser as a WebAssembly binary.</p>
  </figcaption>
</figure>
<p>The WebAssembly binary is in average 86 times faster than the actual
Javascript implementation. The median of the speedup is 98. Some edge
cases are very interesting, like <code>moby-dick-parsed.html</code> where it takes
2.5s with the Javascript parser against 25ms with WebAssembly.</p>
<p>So not only it is safer, but it is faster than Javascript in this case.
And it is only 300 lines of code.</p>
<p>Note that WebAssembly does not support SIMD yet: It is still <a rel="noopener external" target="_blank" href="https://github.com/WebAssembly/simd/blob/master/proposals/simd/SIMD.md">a
proposal</a>.
Rust is gently supporting it (<a rel="noopener external" target="_blank" href="https://github.com/rust-lang-nursery/stdsimd/pull/549">example with PR
#549</a>). It will
dramatically improve the performances!</p>
<p>We will see in the next episodes of this series that Rust can reach a
lot of galaxies, and the more it travels, the more it gets interesting.</p>
<p>Thanks for reading!</p>


    <nav class="previous-next-episodes"><a href="https:&#x2F;&#x2F;mnt.io&#x2F;series&#x2F;from-rust-to-beyond&#x2F;prelude&#x2F;" class="button text-align-start" style="view-transition-name: series-episode-title-prelude">‚ùÆ&nbsp;Prelude</a><a href="https:&#x2F;&#x2F;mnt.io&#x2F;series&#x2F;from-rust-to-beyond&#x2F;the-asm-js-galaxy&#x2F;" class="button text-align-end" style="view-transition-name: series-episode-title-the-asm-js-galaxy">The ASM.js galaxy&nbsp;‚ùØ</a></nav>
  </article>

</main>

<footer class="full-width content-grid">
  <div class="footer">
    <div>
      <h2>Contact me</h2>

      <ul>
        <li><a href="https://matrix.to/#/@mnt_io:matrix.org" title="Say hi on Matrix">@mnt_io:matrix.org</a></li>
        <li><a href="mailto:ivan@mnt.io" title="Good ol' email">ivan@mnt.io</a></li>
        <li><a href="https://floss.social/@hywan" title="Say hi on Mastodon" rel="me">Mastodon</a></li>
        <li><a href="https://github.com/Hywan" title="Say hi on Github">Github</a></li>
      </ul>
    </div>
    <div>
      <h2>Recommendations</h2>

      <ul>
        <li><a href="https://fasterthanli.me/">fasterthanli.me</a></li>
        <li><a href="https://without.boats/blog/">without.boats</a></li>
        <li><a href="https://faultlore.com/blah/">faultlore</a></li>
        <li><a href="https://smallcultfollowing.com/babysteps/blog/">smallcultfollowing</a></li>
        <li><a href="https://orlp.net/blog/">orlp</a></li>
        <li><a href="https://blog.m-ou.se/">m-ou.se</a></li>
        <li><a href="https://nadrieril.github.io/">nadrieril</a></li>
      </ul>
    </div>

    <div>
      <h2>More</h2>

      <ul>
        <li><a href="https://mnt.io/lore/">Lore</a></li>
        <li><a href="https://mnt.io/rss.xml">RSS</a></li>
        <li><a href="https://mnt.io/atom.xml">Atom</a></li>
        <li><a href="https://github.com/Hywan/mnt.io" title="Source code of this site">Source code</a></li>
        <li><a href="https://dblp.org/search/index.php?query=Ivan%20Enderlin" title="Computer Science Bibliography">DBLP</a></li>
      </ul>
    </div>
  </div>
</footer>

<script>
  window.addEventListener('DOMContentLoaded', (_event) => {
    new PagefindUI({
      element: "#search",
      resetStyles: false,
      showSubResults: true,
      showImages: false,
    });
  });
</script>
</body>
</html>
