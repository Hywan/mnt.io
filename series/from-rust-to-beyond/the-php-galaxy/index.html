<!doctype html>
<html lang="en">
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta http-equiv="content-security-policy" content="default-src 'self'; child-src 'self' https://www.youtube-nocookie.com; script-src 'self' 'unsafe-inline' 'wasm-unsafe-eval'; style-src 'self' 'unsafe-inline'; img-src 'self' data:">
  <meta name="viewport" content="width=device-width, minimum-scale=1">

  <title>The PHP galaxy</title>

  <link rel="stylesheet" href="https://mnt.io/style/min/main.css?h=c1d7c9eded14e7411b85">
  <link rel="stylesheet" href="https://mnt.io/style/min/syntax-theme.css?h=ef9797b0398b3ffe9058">
  <link rel="stylesheet" href="https://mnt.io/style/min/search.css" fetchpriority="low">

  <meta name="author" content="Ivan Enderlin">
  <meta name="description" content="This episode is the end of our experimental, and so of our journey. With the C API we have defined, we can now explore the PHP galaxy. First off, we need to discover how to write a PHP extension. Once it&#x27;s done, we can write improve our skeleton extension to use our Rust parser via C. As usual, we will compare our Rust to C to PHP design versus the current PEG.php solution. Is it faster? Once again, it&#x27;s amazing how faster it is!">
  <meta name="keywords" content="rust, binding, gutenberg, c, ffi, php">
  <meta property="og:title" content="The PHP galaxy ‚Äî from the series From Rust to beyond">
  <meta property="og:site_name" content="mnt.io">
  <meta property="og:locale" content="en_GB">
  <meta property="og:type" content="article">
  <meta property="og:url" content="https://mnt.io/series/from-rust-to-beyond/the-php-galaxy/">
  <meta property="og:image" content="https://mnt.io/image/site-poster.jpg">
  <meta name="fediverse:creator" content="@hywan@floss.social">

  <script defer src="https://mnt.io/search/pagefind-ui.js" fetchpriority="low"></script>
</head>
<body class="content-grid">

<nav id="menu" class="full-width content-grid">
  <ul>
    <li><a href="/" accesskey="h">Home</a></li>
    <li><a href="https://mnt.io/articles/" accesskey="a">Articles</a></li>
    <li><a href="https://mnt.io/series/" accesskey="s">Series</a></li>
    <li><a href="https://matrix.to/#/&#x23;mnt_io:matrix.org" title="Public Matrix room to discuss about this blog's content" target="_blank" accesskey="d">Discuss</a></li>
    <li>
      <a href="javascript:document.getElementById('search').showModal()" accesskey="k">
        <svg viewBox="0 0 500 500" class="icon">
          <description>Search</description>
          <circle r="180" cx="210" cy="210" fill="none" stroke="currentColor" stroke-width="40" />
          <line x1="340" y1="340" x2="480" y2="480" stroke="currentColor" stroke-width="40" stroke-linecap="round" />
        </svg>
      </a>
    </li>
  </ul>
</nav>

<dialog id="search" tabindex="-1" closedby="any"></dialog>

<main vocab="https://schema.org">

  <article class="series-episode" typeof="Article" data-pagefind-body>
    <header>
      <h1 property="name" style="view-transition-name: series-episode-title-the-php-galaxy">The PHP galaxy</h1>

      <nav property="isPartOf" typeof="CreativeWorkSeries">
        <p>From the series <a href="/series/from-rust-to-beyond/" property="url"><span property="name">From Rust to beyond</span></a>.</p>
      </nav>

      
  <div class="metadata" data-pagefind-ignore="all">
    <time title="Published date" datetime="2018-10-29" property="datePublished">October 29, 2018</time>
    <span title="Reading time" property="timeRequired" content="PT12M">12 minutes read</span>
    
    <span title="Keywords" property="keywords" content="rust, binding, gutenberg, c, ffi, php">
      Keywords:&nbsp;<a href="/keywords/rust">rust</a>, <a href="/keywords/binding">binding</a>, <a href="/keywords/gutenberg">gutenberg</a>, <a href="/keywords/c">c</a>, <a href="/keywords/ffi">ffi</a>, <a href="/keywords/php">php</a></span>
    
      <span><a href="https://github.com/Hywan/mnt.io/edit/main/content/series&#x2F;from-rust-to-beyond&#x2F;2018-10-29-the-php-galaxy&#x2F;index.md" title="Submit a patch for this page">Edit</a> this page</span>
      
      <meta property="description" content="This episode is the end of our experimental, and so of our journey. With the C API we have defined, we can now explore the PHP galaxy. First off, we need to discover how to write a PHP extension. Once it&#x27;s done, we can write improve our skeleton extension to use our Rust parser via C. As usual, we will compare our Rust to C to PHP design versus the current PEG.php solution. Is it faster? Once again, it&#x27;s amazing how faster it is!" />
      
    
  </div>

    </header>

    <p>The galaxy we will explore today is the PHP galaxy. This post will
explain what PHP is, how to compile any Rust program to C and then to a
PHP native extension.</p>
<h2 id="what-is-php-and-why">What is PHP, and why?<a role="presentation" class="anchor" href="#what-is-php-and-why" title="Anchor link to this header">#</a>
</h2>
<p><a rel="noopener external" target="_blank" href="https://secure.php.net/">PHP</a> is a:</p>
<blockquote>
<p>popular general-purpose scripting language that is especially suited
to Web development. Fast, flexible, and pragmatic, PHP powers
everything from your blog to the most popular websites in the world.</p>
</blockquote>
<p>PHP has sadly acquired a bad reputation along the years, but recent
releases (since PHP 7.0 mostly) have introduced neat language features,
and many cleanups, which are excessively ignored by haters. PHP is also
a fast scripting language, and is very flexible. PHP now has declared
types, traits, variadic arguments, closures (with explicit scopes!),
generators, and a <em>huge</em> backward compatibility. The development of PHP
is led by <a rel="noopener external" target="_blank" href="https://wiki.php.net/rfc">RFCs</a>, which is an open and
democratic process.</p>
<p>The Gutenberg project is a new editor for WordPress. The latter is
written in PHP. This is naturally that we want a native extension for
PHP to parse the Gutenberg post format.</p>
<p>PHP is a language with <a rel="noopener external" target="_blank" href="https://github.com/php/php-langspec">a
specification</a>. The most popular
virtual machine is <a rel="noopener external" target="_blank" href="http://php.net/manual/en/internals2.php">Zend
Engine</a>. Other virtual machines
exist, like <a rel="noopener external" target="_blank" href="https://hhvm.com/">HHVM</a> (but the PHP support has been
dropped recently in favor of their own PHP fork, called Hack),
<a rel="noopener external" target="_blank" href="https://www.peachpie.io/">Peachpie</a>, or <a rel="noopener external" target="_blank" href="https://github.com/tagua-vm/tagua-vm">Tagua
VM</a> (under development).</p>
<p>In this post, we will create an extension for Zend Engine. This virtual
machine is written in C. Great, we have visited <a href="https://mnt.io/series/from-rust-to-beyond/the-c-galaxy/">the C galaxy in the
previous
episode</a>!</p>
<h2 id="rust-rocket-c-rocket-php">Rust üöÄ C üöÄ PHP<a role="presentation" class="anchor" href="#rust-rocket-c-rocket-php" title="Anchor link to this header">#</a>
</h2>
<figure role="presentation">
<p><img src="https://mnt.io/series/from-rust-to-beyond/the-php-galaxy/./rust-to-php.png" alt="Rust to PHP" loading="lazy" decoding="async" /></p>
</figure>
<p>To port our Rust parser into PHP, we first need to port it to C. It&#39;s
been done in the previous episode. Two files result from this port to
C:¬†<code>libgutenberg_post_parser.a</code> and <code>gutenberg_post_parser.h</code>,
respectively a static library, and the header file.</p>
<h3 id="">Bootstrap with a skeleton<a role="presentation" class="anchor" href="#" title="Anchor link to this header">#</a>
</h3>
<p>PHP comes with <a rel="noopener external" target="_blank" href="http://php.net/manual/en/internals2.buildsys.skeleton.php">a script to create an extension
skeleton</a>/template,
called
<a rel="noopener external" target="_blank" href="https://github.com/php/php-src/blob/master/ext/ext_skel.php"><code>ext_skel.php</code></a>.
This script is accessible from the source of the Zend Engine virtual
machine (which we will refer to as <code>php-src</code>). One can invoke the script
like this:</p>
<pre class="giallo z-code"><code data-lang="shellsession"><span class="giallo-l"><span class="z-punctuation z-separator">$</span><span> cd php-src/ext/</span></span>
<span class="giallo-l"><span class="z-punctuation z-separator">$</span><span> ./ext_skel.php \</span></span>
<span class="giallo-l"><span>      --ext gutenberg_post_parser \</span></span>
<span class="giallo-l"><span>      --author &#39;Ivan Enderlin&#39; \</span></span>
<span class="giallo-l"><span>      --dir /path/to/extension \</span></span>
<span class="giallo-l"><span>      --onlyunix</span></span>
<span class="giallo-l"><span class="z-punctuation z-separator">$</span><span> cd /path/to/extension</span></span>
<span class="giallo-l"><span class="z-punctuation z-separator">$</span><span> ls gutenberg_post_parser</span></span>
<span class="giallo-l"><span>tests/</span></span>
<span class="giallo-l"><span>.gitignore</span></span>
<span class="giallo-l"><span>CREDITS</span></span>
<span class="giallo-l"><span>config.m4</span></span>
<span class="giallo-l"><span>gutenberg_post_parser.c</span></span>
<span class="giallo-l"><span>php_gutenberg_post_parser.h</span></span></code></pre>
<p>The <code>ext_skel.php</code> script recommends to go through the following steps:</p>
<ul>
<li>Rebuild the configuration of the PHP source (run <code>./buildconf</code> at the
root of the <code>php-src</code> directory),</li>
<li>Reconfigure the build system to enable the extension, like
<code>./configure --enable-gutenberg_post_parser</code>,</li>
<li>Build with <code>make</code>,</li>
<li>Done.</li>
</ul>
<p>But our extension is very likely to live outside the <code>php-src</code> tree. So
we will use <code>phpize</code> instead. <code>phpize</code> is an executable that comes with
<code>php</code>, <code>php-cgi</code>, <code>phpdbg</code>, <code>php-config</code> etc. It allows to compile
extensions against an already compiled <code>php</code> binary, which is perfect in
our case! We will use it like this :</p>
<pre class="giallo z-code"><code data-lang="shellsession"><span class="giallo-l"><span class="z-punctuation z-separator">$</span><span> cd /path/to/extension/gutenberg_post_parser</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span class="z-punctuation z-separator">$</span><span> # Get the bin directory </span><span class="z-keyword">for</span><span> PHP utilities.</span></span>
<span class="giallo-l"><span class="z-punctuation z-separator">$</span><span class="z-variable"> PHP_PREFIX_BIN</span><span class="z-keyword z-operator">=</span><span>$(</span><span class="z-entity z-name">php-config</span><span class="z-constant z-other"> --prefix</span><span>)</span><span class="z-string">/bin</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span class="z-punctuation z-separator">$</span><span> # Clean (</span><span class="z-entity z-name">except</span><span class="z-string"> if it is the first run</span><span>).</span></span>
<span class="giallo-l"><span class="z-punctuation z-separator">$</span><span class="z-variable"> $PHP_PREFIX_BIN</span><span>/phpize --clean</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span class="z-punctuation z-separator">$</span><span> # ‚Äúphpize‚Äù the extension.</span></span>
<span class="giallo-l"><span class="z-punctuation z-separator">$</span><span class="z-variable"> $PHP_PREFIX_BIN</span><span>/phpize</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span class="z-punctuation z-separator">$</span><span> # Configure the extension </span><span class="z-keyword">for</span><span> a particular PHP version.</span></span>
<span class="giallo-l"><span class="z-punctuation z-separator">$</span><span> ./configure</span><span class="z-variable"> --with-php-config</span><span class="z-keyword z-operator">=</span><span class="z-variable">$PHP_PREFIX_BIN</span><span class="z-string">/php-config</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span class="z-punctuation z-separator">$</span><span> # Compile.</span></span>
<span class="giallo-l"><span class="z-punctuation z-separator">$</span><span> make install</span></span></code></pre>
<p>In this post, we will not show all the edits we have done, but we will
rather focus on the extension binding. <a rel="noopener external" target="_blank" href="https://github.com/Hywan/gutenberg-parser-rs/tree/master/bindings/php/extension/gutenberg_post_parser">All the sources can be found
here</a>.
Shortly, here is the <code>config.m4</code> file:</p>
<pre class="giallo z-code"><code data-lang="plain"><span class="giallo-l"><span>PHP_ARG_ENABLE(gutenberg_post_parser, whether to enable gutenberg_post_parser support,</span></span>
<span class="giallo-l"><span>[  --with-gutenberg_post_parser          Include gutenberg_post_parser support], no)</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>if¬† test &quot;$PHP_GUTENBERG_POST_PARSER&quot; != &quot;no&quot;; then</span></span>
<span class="giallo-l"><span>¬† PHP_SUBST(GUTENBERG_POST_PARSER_SHARED_LIBADD)</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>¬† PHP_ADD_LIBRARY_WITH_PATH(gutenberg_post_parser, ., GUTENBERG_POST_PARSER_SHARED_LIBADD)</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>¬† PHP_NEW_EXTENSION(gutenberg_post_parser, gutenberg_post_parser.c, $ext_shared)</span></span>
<span class="giallo-l"><span>fi</span></span></code></pre>
<p>What it does is basically the following:</p>
<ul>
<li>Register the <code>--with-gutenberg_post_parser</code> option in the build
system, and</li>
<li>Declare the static library to compile with, and the source of the
extension itself.</li>
</ul>
<p>We must add the <code>libgutenberg_post_parser.a</code> and
<code>gutenberg_post_parser.h</code> files in the same directory (a symlink is
perfect), to get a structure such as:</p>
<pre class="giallo z-code"><code data-lang="shellsession"><span class="giallo-l"><span class="z-punctuation z-separator">$</span><span> ls gutenberg_post_parser</span></span>
<span class="giallo-l"><span>tests/                       # from ext_skel</span></span>
<span class="giallo-l"><span>.gitignore                   # from ext_skel</span></span>
<span class="giallo-l"><span>CREDITS                      # from ext_skel</span></span>
<span class="giallo-l"><span>config.m4                    # from ext_skel (edited)</span></span>
<span class="giallo-l"><span>gutenberg_post_parser.c      # from ext_skel (will be edited)</span></span>
<span class="giallo-l"><span>gutenberg_post_parser.h      # from Rust</span></span>
<span class="giallo-l"><span>libgutenberg_post_parser.a   # from Rust</span></span>
<span class="giallo-l"><span>php_gutenberg_post_parser.h  # from ext_skel</span></span></code></pre>
<p>The core of the extension is the <code>gutenberg_post_parser.c</code> file. This
file is responsible to create the module, and to bind our Rust code to
PHP.</p>
<h3 id="-1">The module, aka the extension<a role="presentation" class="anchor" href="#-1" title="Anchor link to this header">#</a>
</h3>
<p>As said, we will work in the <code>gutenberg_post_parser.c</code> file. First,
let&#39;s include everything we need:</p>
<pre class="giallo z-code"><code data-lang="c"><span class="giallo-l"><span class="z-keyword">#include</span><span class="z-string"> &quot;php.h&quot;</span></span>
<span class="giallo-l"><span class="z-keyword">#include</span><span class="z-string"> &quot;ext/standard/info.h&quot;</span></span>
<span class="giallo-l"><span class="z-keyword">#include</span><span class="z-string"> &quot;php_gutenberg_post_parser.h&quot;</span></span>
<span class="giallo-l"><span class="z-keyword">#include</span><span class="z-string"> &quot;gutenberg_post_parser.h&quot;</span></span></code></pre>
<p>The last line includes the <code>gutenberg_post_parser.h</code> file generated by
Rust (more precisely, by <code>cbindgen</code>, if you don&#39;t remember,¬†<a href="https://mnt.io/series/from-rust-to-beyond/the-c-galaxy/">take a look
at the previous
episode</a>).</p>
<p>Then, we have to decide what API we want to expose into PHP? As a
reminder, the Rust parser produces an AST defined as:</p>
<pre class="giallo z-code"><code data-lang="rust"><span class="giallo-l"><span class="z-keyword">pub</span><span class="z-storage"> enum</span><span class="z-entity z-name"> Node</span><span>&lt;&#39;</span><span class="z-entity z-name">a</span><span>&gt; {</span></span>
<span class="giallo-l"><span class="z-entity z-name">    Block</span><span> {</span></span>
<span class="giallo-l"><span class="z-variable">        name</span><span class="z-keyword z-operator">:</span><span> (</span><span class="z-entity z-name">Input</span><span>&lt;&#39;</span><span class="z-entity z-name">a</span><span>&gt;,</span><span class="z-entity z-name"> Input</span><span>&lt;&#39;</span><span class="z-entity z-name">a</span><span>&gt;),</span></span>
<span class="giallo-l"><span class="z-variable">        attributes</span><span class="z-keyword z-operator">:</span><span class="z-entity z-name"> Option</span><span>&lt;</span><span class="z-entity z-name">Input</span><span>&lt;&#39;</span><span class="z-entity z-name">a</span><span>&gt;&gt;,</span></span>
<span class="giallo-l"><span class="z-variable">        children</span><span class="z-keyword z-operator">:</span><span class="z-entity z-name"> Vec</span><span>&lt;</span><span class="z-entity z-name">Node</span><span>&lt;&#39;</span><span class="z-entity z-name">a</span><span>&gt;&gt;</span></span>
<span class="giallo-l"><span>    },</span></span>
<span class="giallo-l"><span class="z-entity z-name z-function">    Phrase</span><span>(</span><span class="z-entity z-name">Input</span><span>&lt;&#39;</span><span class="z-entity z-name">a</span><span>&gt;)</span></span>
<span class="giallo-l"><span>}</span></span></code></pre>
<p>The C variant of the AST is very similar (with more structures, but the
idea is almost identical). So in PHP, the following structure has been
selected:</p>
<pre class="giallo z-code"><code data-lang="php"><span class="giallo-l"><span class="z-keyword z-operator">&lt;?</span><span class="z-constant z-other">php</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span class="z-storage">class</span><span class="z-entity z-name">¬†Gutenberg_Parser_Block</span><span> {</span></span>
<span class="giallo-l"><span class="z-storage">    public</span><span class="z-keyword"> string</span><span class="z-variable"> $namespace</span><span class="z-punctuation z-terminator">;</span></span>
<span class="giallo-l"><span class="z-storage">    public</span><span class="z-keyword"> string</span><span class="z-variable"> $name</span><span class="z-punctuation z-terminator">;</span></span>
<span class="giallo-l"><span class="z-storage">    public</span><span class="z-keyword"> string</span><span class="z-variable"> $attributes</span><span class="z-punctuation z-terminator">;</span></span>
<span class="giallo-l"><span class="z-storage">    public</span><span class="z-keyword"> array</span><span class="z-variable"> $children</span><span class="z-punctuation z-terminator">;</span></span>
<span class="giallo-l"><span>}</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span class="z-storage">class</span><span class="z-entity z-name"> Gutenberg_Parser_Phrase</span><span> {</span></span>
<span class="giallo-l"><span class="z-storage">    public</span><span class="z-keyword"> string</span><span class="z-variable"> $content</span><span class="z-punctuation z-terminator">;</span></span>
<span class="giallo-l"><span>}</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span class="z-storage z-type z-function">function</span><span class="z-entity z-name z-function"> gutenberg_post_parse</span><span>(</span><span class="z-keyword">string</span><span class="z-variable"> $gutenberg_post</span><span>)</span><span class="z-keyword z-operator">:</span><span class="z-keyword"> array</span><span class="z-punctuation z-terminator">;</span></span></code></pre>
<p>The <code>gutenberg_post_parse</code> function will output an array of objects of
kind <code>Gutenberg_Parser_Block</code> or <code>Gutenberg_Parser_Phrase</code>, i.e. our
AST.</p>
<p>So, let&#39;s declare those classes!</p>
<h3 id="-2">Declare the classes<a role="presentation" class="anchor" href="#-2" title="Anchor link to this header">#</a>
</h3>
<p><em>Note: The next 4 code blocks are not the core of the post, it is just
code that needs to be written, you can skip it if you are not about to
write a PHP extension.</em></p>
<pre class="giallo z-code"><code data-lang="c"><span class="giallo-l"><span>zend_class_entry </span><span class="z-keyword z-operator">*</span><span>gutenberg_parser_block_class_entry</span><span class="z-punctuation z-terminator">;</span></span>
<span class="giallo-l"><span>zend_class_entry </span><span class="z-keyword z-operator">*</span><span>gutenberg_parser_phrase_class_entry</span><span class="z-punctuation z-terminator">;</span></span>
<span class="giallo-l"><span>zend_object_handlers gutenberg_parser_node_class_entry_handlers</span><span class="z-punctuation z-terminator">;</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span class="z-keyword">typedef</span><span class="z-storage z-type"> struct</span><span> _gutenberg_parser_node </span><span class="z-punctuation z-section">{</span></span>
<span class="giallo-l"><span>    zend_object zobj</span><span class="z-punctuation z-terminator">;</span></span>
<span class="giallo-l"><span class="z-punctuation z-section">}</span><span> gutenberg_parser_node</span><span class="z-punctuation z-terminator">;</span></span></code></pre>
<p>A class entry represents a specific class type. A handler is associated
to a class entry. The logic is somewhat complicated. If you need more
details, I recommend to read the <a rel="noopener external" target="_blank" href="http://www.phpinternalsbook.com/">PHP Internals
Book</a>.</p>
<p>Then, let&#39;s create a function to instanciate those objects:</p>
<pre class="giallo z-code"><code data-lang="c"><span class="giallo-l"><span class="z-storage">static</span><span> zend_object </span><span class="z-keyword z-operator">*</span><span class="z-entity z-name z-function">create_parser_node_object</span><span class="z-punctuation z-section">(</span><span>zend_class_entry </span><span class="z-keyword z-operator">*</span><span class="z-variable z-parameter">class_entry</span><span class="z-punctuation z-section">)</span></span>
<span class="giallo-l"><span class="z-punctuation z-section">{</span></span>
<span class="giallo-l"><span>    gutenberg_parser_node </span><span class="z-keyword z-operator">*</span><span>gutenberg_parser_node_object</span><span class="z-punctuation z-terminator">;</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    gutenberg_parser_node_object </span><span class="z-keyword z-operator">=</span><span class="z-entity z-name z-function"> ecalloc</span><span class="z-punctuation z-section">(</span><span class="z-constant z-numeric">1</span><span class="z-punctuation z-separator">,</span><span class="z-keyword z-operator"> sizeof</span><span class="z-punctuation z-section">(</span><span class="z-keyword z-operator">*</span><span>gutenberg_parser_node_object</span><span class="z-punctuation z-section">)</span><span class="z-keyword z-operator"> +</span><span class="z-entity z-name z-function"> zend_object_properties_size</span><span class="z-punctuation z-section">(</span><span>class_entry</span><span class="z-punctuation z-section">))</span><span class="z-punctuation z-terminator">;</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span class="z-entity z-name z-function">    zend_object_std_init</span><span class="z-punctuation z-section">(</span><span class="z-keyword z-operator">&amp;</span><span class="z-variable">gutenberg_parser_node_object</span><span class="z-punctuation z-separator">-&gt;</span><span class="z-variable">zobj</span><span class="z-punctuation z-separator">,</span><span> class_entry</span><span class="z-punctuation z-section">)</span><span class="z-punctuation z-terminator">;</span></span>
<span class="giallo-l"><span class="z-entity z-name z-function">    object_properties_init</span><span class="z-punctuation z-section">(</span><span class="z-keyword z-operator">&amp;</span><span class="z-variable">gutenberg_parser_node_object</span><span class="z-punctuation z-separator">-&gt;</span><span class="z-variable">zobj</span><span class="z-punctuation z-separator">,</span><span> class_entry</span><span class="z-punctuation z-section">)</span><span class="z-punctuation z-terminator">;</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span class="z-variable">    gutenberg_parser_node_object</span><span class="z-punctuation z-separator">-&gt;</span><span class="z-variable">zobj</span><span class="z-punctuation z-separator">.</span><span class="z-variable">handlers</span><span class="z-keyword z-operator"> = &amp;</span><span>gutenberg_parser_node_class_entry_handlers</span><span class="z-punctuation z-terminator">;</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span class="z-keyword">    return</span><span class="z-keyword z-operator"> &amp;</span><span class="z-variable">gutenberg_parser_node_object</span><span class="z-punctuation z-separator">-&gt;</span><span class="z-variable">zobj</span><span class="z-punctuation z-terminator">;</span></span>
<span class="giallo-l"><span class="z-punctuation z-section">}</span></span></code></pre>
<p>Then, let&#39;s create a function to free those objects. It works in two
steps: Destruct the object by calling its destructor (in the user-land),
then free it for real (in the VM-land):</p>
<pre class="giallo z-code"><code data-lang="c"><span class="giallo-l"><span class="z-storage">static</span><span class="z-storage z-type"> void</span><span class="z-entity z-name z-function"> destroy_parser_node_object</span><span class="z-punctuation z-section">(</span><span>zend_object </span><span class="z-keyword z-operator">*</span><span class="z-variable z-parameter">gutenberg_parser_node_object</span><span class="z-punctuation z-section">)</span></span>
<span class="giallo-l"><span class="z-punctuation z-section">{</span></span>
<span class="giallo-l"><span class="z-entity z-name z-function">    zend_objects_destroy_object</span><span class="z-punctuation z-section">(</span><span>gutenberg_parser_node_object</span><span class="z-punctuation z-section">)</span><span class="z-punctuation z-terminator">;</span></span>
<span class="giallo-l"><span class="z-punctuation z-section">}</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span class="z-storage">static</span><span class="z-storage z-type"> void</span><span class="z-entity z-name z-function"> free_parser_node_object</span><span class="z-punctuation z-section">(</span><span>zend_object </span><span class="z-keyword z-operator">*</span><span class="z-variable z-parameter">gutenberg_parser_node_object</span><span class="z-punctuation z-section">)</span></span>
<span class="giallo-l"><span class="z-punctuation z-section">{</span></span>
<span class="giallo-l"><span class="z-entity z-name z-function">    zend_object_std_dtor</span><span class="z-punctuation z-section">(</span><span>gutenberg_parser_node_object</span><span class="z-punctuation z-section">)</span><span class="z-punctuation z-terminator">;</span></span>
<span class="giallo-l"><span class="z-punctuation z-section">}</span></span></code></pre>
<p>Then, let&#39;s initialize the ‚Äúmodule‚Äù, i.e. the extension. During the
initialisation, we will create the classes in the user-land, declare
their attributes etc.</p>
<pre class="giallo z-code"><code data-lang="c"><span class="giallo-l"><span class="z-entity z-name z-function">PHP_MINIT_FUNCTION</span><span class="z-punctuation z-section">(</span><span>gutenberg_post_parser</span><span class="z-punctuation z-section">)</span></span>
<span class="giallo-l"><span class="z-punctuation z-section">{</span></span>
<span class="giallo-l"><span>    zend_class_entry class_entry</span><span class="z-punctuation z-terminator">;</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span class="z-comment">    // Declare Gutenberg_Parser_Block.</span></span>
<span class="giallo-l"><span class="z-entity z-name z-function">    INIT_CLASS_ENTRY</span><span class="z-punctuation z-section">(</span><span>class_entry</span><span class="z-punctuation z-separator">,</span><span class="z-string"> &quot;Gutenberg_Parser_Block&quot;</span><span class="z-punctuation z-separator">,</span><span class="z-constant z-language"> NULL</span><span class="z-punctuation z-section">)</span><span class="z-punctuation z-terminator">;</span></span>
<span class="giallo-l"><span>    gutenberg_parser_block_class_entry </span><span class="z-keyword z-operator">=</span><span class="z-entity z-name z-function"> zend_register_internal_class</span><span class="z-punctuation z-section">(</span><span class="z-keyword z-operator">&amp;</span><span>class_entry TSRMLS_CC</span><span class="z-punctuation z-section">)</span><span class="z-punctuation z-terminator">;</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span class="z-comment">    // Declare the create handler.</span></span>
<span class="giallo-l"><span class="z-variable">    gutenberg_parser_block_class_entry</span><span class="z-punctuation z-separator">-&gt;</span><span class="z-variable">create_object</span><span class="z-keyword z-operator"> =</span><span> create_parser_node_object</span><span class="z-punctuation z-terminator">;</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span class="z-comment">    // The class is final.</span></span>
<span class="giallo-l"><span class="z-variable">    gutenberg_parser_block_class_entry</span><span class="z-punctuation z-separator">-&gt;</span><span class="z-variable">ce_flags</span><span class="z-keyword z-operator"> |=</span><span> ZEND_ACC_FINAL</span><span class="z-punctuation z-terminator">;</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span class="z-comment">    // Declare the `namespace` public attribute,</span></span>
<span class="giallo-l"><span class="z-comment">    // with an empty string for the default value.</span></span>
<span class="giallo-l"><span class="z-entity z-name z-function">    zend_declare_property_string</span><span class="z-punctuation z-section">(</span><span>gutenberg_parser_block_class_entry</span><span class="z-punctuation z-separator">,</span><span class="z-string"> &quot;namespace&quot;</span><span class="z-punctuation z-separator">,</span><span class="z-keyword z-operator"> sizeof</span><span class="z-punctuation z-section">(</span><span class="z-string">&quot;namespace&quot;</span><span class="z-punctuation z-section">)</span><span class="z-keyword z-operator"> -</span><span class="z-constant z-numeric"> 1</span><span class="z-punctuation z-separator">,</span><span class="z-string"> &quot;&quot;</span><span class="z-punctuation z-separator">,</span><span> ZEND_ACC_PUBLIC</span><span class="z-punctuation z-section">)</span><span class="z-punctuation z-terminator">;</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span class="z-comment">    // Declare the `name` public attribute,</span></span>
<span class="giallo-l"><span class="z-comment">    // with an empty string for the default value.</span></span>
<span class="giallo-l"><span class="z-entity z-name z-function">    zend_declare_property_string</span><span class="z-punctuation z-section">(</span><span>gutenberg_parser_block_class_entry</span><span class="z-punctuation z-separator">,</span><span class="z-string"> &quot;name&quot;</span><span class="z-punctuation z-separator">,</span><span class="z-keyword z-operator"> sizeof</span><span class="z-punctuation z-section">(</span><span class="z-string">&quot;name&quot;</span><span class="z-punctuation z-section">)</span><span class="z-keyword z-operator"> -</span><span class="z-constant z-numeric"> 1</span><span class="z-punctuation z-separator">,</span><span class="z-string"> &quot;&quot;</span><span class="z-punctuation z-separator">,</span><span> ZEND_ACC_PUBLIC</span><span class="z-punctuation z-section">)</span><span class="z-punctuation z-terminator">;</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span class="z-comment">    // Declare the `attributes` public attribute,</span></span>
<span class="giallo-l"><span class="z-comment">    // with `NULL` for the default value.</span></span>
<span class="giallo-l"><span class="z-entity z-name z-function">    zend_declare_property_null</span><span class="z-punctuation z-section">(</span><span>gutenberg_parser_block_class_entry</span><span class="z-punctuation z-separator">,</span><span class="z-string"> &quot;attributes&quot;</span><span class="z-punctuation z-separator">,</span><span class="z-keyword z-operator"> sizeof</span><span class="z-punctuation z-section">(</span><span class="z-string">&quot;attributes&quot;</span><span class="z-punctuation z-section">)</span><span class="z-keyword z-operator"> -</span><span class="z-constant z-numeric"> 1</span><span class="z-punctuation z-separator">,</span><span> ZEND_ACC_PUBLIC</span><span class="z-punctuation z-section">)</span><span class="z-punctuation z-terminator">;</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span class="z-comment">    // Declare the `children` public attribute,</span></span>
<span class="giallo-l"><span class="z-comment">    // with `NULL` for the default value.</span></span>
<span class="giallo-l"><span class="z-entity z-name z-function">    zend_declare_property_null</span><span class="z-punctuation z-section">(</span><span>gutenberg_parser_block_class_entry</span><span class="z-punctuation z-separator">,</span><span class="z-string"> &quot;children&quot;</span><span class="z-punctuation z-separator">,</span><span class="z-keyword z-operator"> sizeof</span><span class="z-punctuation z-section">(</span><span class="z-string">&quot;children&quot;</span><span class="z-punctuation z-section">)</span><span class="z-keyword z-operator"> -</span><span class="z-constant z-numeric"> 1</span><span class="z-punctuation z-separator">,</span><span> ZEND_ACC_PUBLIC</span><span class="z-punctuation z-section">)</span><span class="z-punctuation z-terminator">;</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span class="z-comment">    // Declare the Gutenberg_Parser_Block.</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    ‚Ä¶ skip ‚Ä¶</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span class="z-comment">¬†¬†¬† // Declare Gutenberg parser node object handlers.</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span class="z-entity z-name z-function">¬†¬†¬†¬†memcpy</span><span class="z-punctuation z-section">(</span><span class="z-keyword z-operator">&amp;</span><span>gutenberg_parser_node_class_entry_handlers</span><span class="z-punctuation z-separator">,</span><span class="z-entity z-name z-function"> zend_get_std_object_handlers</span><span class="z-punctuation z-section">()</span><span class="z-punctuation z-separator">,</span><span class="z-keyword z-operator"> sizeof</span><span class="z-punctuation z-section">(</span><span>gutenberg_parser_node_class_entry_handlers</span><span class="z-punctuation z-section">))</span><span class="z-punctuation z-terminator">;</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span class="z-variable">    gutenberg_parser_node_class_entry_handlers</span><span class="z-punctuation z-separator">.</span><span class="z-variable">offset</span><span class="z-keyword z-operator"> =</span><span class="z-entity z-name z-function"> XtOffsetOf</span><span class="z-punctuation z-section">(</span><span>gutenberg_parser_node</span><span class="z-punctuation z-separator">,</span><span> zobj</span><span class="z-punctuation z-section">)</span><span class="z-punctuation z-terminator">;</span></span>
<span class="giallo-l"><span class="z-variable">    gutenberg_parser_node_class_entry_handlers</span><span class="z-punctuation z-separator">.</span><span class="z-variable">dtor_obj</span><span class="z-keyword z-operator"> =</span><span> destroy_parser_node_object</span><span class="z-punctuation z-terminator">;</span></span>
<span class="giallo-l"><span class="z-variable">    gutenberg_parser_node_class_entry_handlers</span><span class="z-punctuation z-separator">.</span><span class="z-variable">free_obj</span><span class="z-keyword z-operator"> =</span><span> free_parser_node_object</span><span class="z-punctuation z-terminator">;</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span class="z-keyword">    return</span><span> SUCCESS</span><span class="z-punctuation z-terminator">;</span></span>
<span class="giallo-l"><span class="z-punctuation z-section">}</span></span></code></pre>
<p>If you are still reading, first: Thank you, and second: Congrats!</p>
<p>Then, there is a <code>PHP_RINIT_FUNCTION</code> and a <code>PHP_MINFO_FUNCTION</code>
functions that are already generated by the <code>ext_skel.php</code> script. Same
for the module entry definition and other module configuration details.</p>
<h3 id="gutenberg-post-parse">The <code>gutenberg_post_parse</code> function<a role="presentation" class="anchor" href="#gutenberg-post-parse" title="Anchor link to this header">#</a>
</h3>
<p>We will now focus on the <code>gutenberg_post_parse</code> PHP function. This
function takes a string as a single argument¬† and returns either <code>false</code>
if the parsing failed, or an array of objects of kind
<code>Gutenberg_Parser_Block</code> or <code>Gutenberg_Parser_Phrase</code> otherwise. Let&#39;s
write it! Notice that it is declared with <a rel="noopener external" target="_blank" href="https://github.com/php/php-src/blob/52d91260df54995a680f420884338dfd9d5a0d49/main/php.h#L400">the <code>PHP_FUNCTION</code>
macro</a>.</p>
<pre class="giallo z-code"><code data-lang="c"><span class="giallo-l"><span class="z-entity z-name z-function">PHP_FUNCTION</span><span class="z-punctuation z-section">(</span><span>gutenberg_post_parse</span><span class="z-punctuation z-section">)</span></span>
<span class="giallo-l"><span class="z-punctuation z-section">{</span></span>
<span class="giallo-l"><span class="z-storage z-type">    char</span><span class="z-keyword z-operator"> *</span><span>input</span><span class="z-punctuation z-terminator">;</span></span>
<span class="giallo-l"><span class="z-storage z-type">    size_t</span><span> input_len</span><span class="z-punctuation z-terminator">;</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span class="z-comment">    // Read the input as a string.</span></span>
<span class="giallo-l"><span class="z-keyword">    if</span><span class="z-punctuation z-section"> (</span><span class="z-entity z-name z-function">zend_parse_parameters</span><span class="z-punctuation z-section">(</span><span class="z-entity z-name z-function">ZEND_NUM_ARGS</span><span class="z-punctuation z-section">()</span><span> TSRMLS_CC</span><span class="z-punctuation z-separator">,</span><span class="z-string"> &quot;s&quot;</span><span class="z-punctuation z-separator">,</span><span class="z-keyword z-operator"> &amp;</span><span>input</span><span class="z-punctuation z-separator">,</span><span class="z-keyword z-operator"> &amp;</span><span>input_len</span><span class="z-punctuation z-section">)</span><span class="z-keyword z-operator"> ==</span><span> FAILURE</span><span class="z-punctuation z-section">) {</span></span>
<span class="giallo-l"><span class="z-keyword">        return</span><span class="z-punctuation z-terminator">;</span></span>
<span class="giallo-l"><span class="z-punctuation z-section">    }</span></span></code></pre>
<p>At this step, the argument has been declared and typed as a string
(<code>"s"</code>). The string value is in <code>input</code> and the string length is in
<code>input_len</code>.</p>
<p>The next step is to parse the <code>input</code>. (The length of the string is not
needed). This is where we are going to call our Rust code! Let&#39;s do
that:</p>
<pre class="giallo z-code"><code data-lang="c"><span class="giallo-l"><span class="z-comment"> ¬†¬† // Parse the input.</span></span>
<span class="giallo-l"><span>¬†¬†¬† Result parser_result </span><span class="z-keyword z-operator">=</span><span class="z-entity z-name z-function"> parse</span><span class="z-punctuation z-section">(</span><span>input</span><span class="z-punctuation z-section">)</span><span class="z-punctuation z-terminator">;</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span class="z-comment">¬†¬†¬† // If parsing failed, then return false.</span></span>
<span class="giallo-l"><span class="z-keyword">¬†¬†¬† if</span><span class="z-punctuation z-section"> (</span><span>parser_result.tag </span><span class="z-keyword z-operator">==</span><span> Err</span><span class="z-punctuation z-section">) {</span></span>
<span class="giallo-l"><span>¬†¬†¬†¬†¬†¬†¬† RETURN_FALSE</span><span class="z-punctuation z-terminator">;</span></span>
<span class="giallo-l"><span class="z-punctuation z-section">¬†¬†¬† }</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span class="z-comment">¬†¬†¬† // Else map the Rust AST into a PHP array.</span></span>
<span class="giallo-l"><span class="z-storage">¬†¬†¬† const</span><span> Vector_Node nodes </span><span class="z-keyword z-operator">=</span><span> parse_result.ok._0</span><span class="z-punctuation z-terminator">;</span></span></code></pre>
<p>The <code>Result</code> type and the <code>parse</code> function come from Rust. If you don&#39;t
remember those types, please <a href="https://mnt.io/series/from-rust-to-beyond/the-c-galaxy/">read the previous episode about the C
galaxy</a>.</p>
<p>Zend Engine has a macro called <code>RETURN_FALSE</code> to return‚Ä¶ <code>false</code>! Handy
isn&#39;t it?</p>
<p>Finally, if everything went well, we get back a collection of node as a
<code>Vector_Node</code> type.</p>
<p>The next step is to map those Rust/C types into PHP types, i.e. an array
of the Gutenberg classes. Let&#39;s go:</p>
<pre class="giallo z-code"><code data-lang="c"><span class="giallo-l"><span class="z-comment"> ¬†¬† // Note: return_value is a ‚Äúmagic‚Äù variable that holds the value to be returned.</span></span>
<span class="giallo-l"><span class="z-comment">    //</span></span>
<span class="giallo-l"><span class="z-comment">¬†¬†¬† // Allocate an array.</span></span>
<span class="giallo-l"><span class="z-entity z-name z-function">¬†¬†¬† array_init_size</span><span class="z-punctuation z-section">(</span><span>return_value</span><span class="z-punctuation z-separator">,</span><span> nodes.length</span><span class="z-punctuation z-section">)</span><span class="z-punctuation z-terminator">;</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span class="z-comment">¬†¬†¬† // Map the Rust AST.</span></span>
<span class="giallo-l"><span class="z-entity z-name z-function">¬†¬†¬† into_php_objects</span><span class="z-punctuation z-section">(</span><span>return_value</span><span class="z-punctuation z-separator">,</span><span class="z-keyword z-operator"> &amp;</span><span class="z-variable z-parameter">nodes</span><span class="z-punctuation z-section">)</span><span class="z-punctuation z-terminator">;</span></span>
<span class="giallo-l"><span>}</span></span></code></pre>
<p>Done üòÅ! Oh wait‚Ä¶ the <code>into_php_objects</code> function need to be written!</p>
<h3 id="into-php-objects">The <code>into_php_objects</code> function<a role="presentation" class="anchor" href="#into-php-objects" title="Anchor link to this header">#</a>
</h3>
<p>This function is not terribly complex: It&#39;s just full of Zend Engine
specific API as expected. We are going to explain how to map a <code>Block</code>
into a <code>Gutenberg_Parser_Block</code>¬†object, and to let the <code>Phrase</code> mapping
to <code>Gutenberg_Parser_Phrase</code> for the assiduous readers. And there we go:</p>
<pre class="giallo z-code"><code data-lang="c"><span class="giallo-l"><span class="z-storage z-type">void</span><span class="z-entity z-name z-function"> into_php_objects</span><span class="z-punctuation z-section">(</span><span>zval </span><span class="z-keyword z-operator">*</span><span class="z-variable z-parameter">php_array</span><span class="z-punctuation z-separator">,</span><span class="z-storage"> const</span><span> Vector_Node </span><span class="z-keyword z-operator">*</span><span class="z-variable z-parameter">nodes</span><span class="z-punctuation z-section">)</span></span>
<span class="giallo-l"><span class="z-punctuation z-section">{</span></span>
<span class="giallo-l"><span class="z-storage">    const</span><span class="z-storage z-type"> uintptr_t</span><span> number_of_nodes </span><span class="z-keyword z-operator">=</span><span class="z-variable"> nodes</span><span class="z-punctuation z-separator">-&gt;</span><span class="z-variable">length</span><span class="z-punctuation z-terminator">;</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span class="z-keyword">    if</span><span class="z-punctuation z-section"> (</span><span>number_of_nodes </span><span class="z-keyword z-operator">==</span><span class="z-constant z-numeric"> 0</span><span class="z-punctuation z-section">) {</span></span>
<span class="giallo-l"><span class="z-keyword">        return</span><span class="z-punctuation z-terminator">;</span></span>
<span class="giallo-l"><span class="z-punctuation z-section">    }</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span class="z-comment">    // Iterate over all nodes.</span></span>
<span class="giallo-l"><span class="z-keyword">    for</span><span class="z-punctuation z-section"> (</span><span class="z-storage z-type">uintptr_t</span><span> nth </span><span class="z-keyword z-operator">=</span><span class="z-constant z-numeric"> 0</span><span class="z-punctuation z-terminator">;</span><span> nth </span><span class="z-keyword z-operator">&lt;</span><span> number_of_nodes</span><span class="z-punctuation z-terminator">;</span><span class="z-keyword z-operator"> ++</span><span>nth</span><span class="z-punctuation z-section">) {</span></span>
<span class="giallo-l"><span class="z-storage">        const</span><span> Node node </span><span class="z-keyword z-operator">=</span><span class="z-variable"> nodes</span><span class="z-punctuation z-separator">-&gt;</span><span class="z-variable">buffer</span><span>[nth]</span><span class="z-punctuation z-terminator">;</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span class="z-keyword">        if</span><span class="z-punctuation z-section"> (</span><span class="z-variable">node</span><span class="z-punctuation z-separator">.</span><span class="z-variable">tag</span><span class="z-keyword z-operator"> ==</span><span> Block</span><span class="z-punctuation z-section">) {</span></span>
<span class="giallo-l"><span class="z-comment">            // Map Block into Gutenberg_Parser_Block.</span></span>
<span class="giallo-l"><span class="z-punctuation z-section">        }</span><span class="z-keyword"> else if</span><span class="z-punctuation z-section"> (</span><span class="z-variable">node</span><span class="z-punctuation z-separator">.</span><span class="z-variable">tag</span><span class="z-keyword z-operator"> ==</span><span> Phrase</span><span class="z-punctuation z-section">) {</span></span>
<span class="giallo-l"><span class="z-comment">            // Map Phrase into Gutenberg_Parser_Phrase.</span></span>
<span class="giallo-l"><span class="z-punctuation z-section">        }</span></span>
<span class="giallo-l"><span class="z-punctuation z-section">    }</span></span>
<span class="giallo-l"><span class="z-punctuation z-section">}</span></span></code></pre>
<p>Now let&#39;s map a block. The process is the following:</p>
<ol>
<li>Allocate PHP strings for the block namespace, and for the block
name,</li>
<li>Allocate an object,</li>
<li>Set the block namespace and the block name to their respective
object properties,</li>
<li>Allocate a PHP string for the block attributes if any,</li>
<li>Set the block attributes to its respective object property,</li>
<li>If any children, initialise a new array, and call <code>into_php_objects</code>
with the child nodes and the new array,</li>
<li>Set the children to its respective object property,</li>
<li>Finally, add the block object inside the array to be returned.</li>
</ol>
<pre class="giallo z-code"><code data-lang="c"><span class="giallo-l"><span class="z-storage">const</span><span> Block_Body block </span><span class="z-keyword z-operator">=</span><span> node.block</span><span class="z-punctuation z-terminator">;</span></span>
<span class="giallo-l"><span>zval php_block</span><span class="z-punctuation z-separator">,</span><span> php_block_namespace</span><span class="z-punctuation z-separator">,</span><span> php_block_name</span><span class="z-punctuation z-terminator">;</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span class="z-comment">// 1. Prepare the PHP strings.</span></span>
<span class="giallo-l"><span class="z-entity z-name z-function">ZVAL_STRINGL</span><span class="z-punctuation z-section">(</span><span class="z-keyword z-operator">&amp;</span><span class="z-variable z-parameter">php_block_namespace</span><span class="z-punctuation z-separator">,</span><span> block.namespace.pointer</span><span class="z-punctuation z-separator">,</span><span> block.namespace.length</span><span class="z-punctuation z-section">)</span><span class="z-punctuation z-terminator">;</span></span>
<span class="giallo-l"><span class="z-entity z-name z-function">ZVAL_STRINGL</span><span class="z-punctuation z-section">(</span><span class="z-keyword z-operator">&amp;</span><span class="z-variable z-parameter">php_block_name</span><span class="z-punctuation z-separator">,</span><span> block.name.pointer</span><span class="z-punctuation z-separator">,</span><span> block.name.length</span><span class="z-punctuation z-section">)</span><span class="z-punctuation z-terminator">;</span></span></code></pre>
<p>Do you remember that namespace, name and other similar data are of type
<code>Slice_c_char</code>? It&#39;s just a structure with a pointer and a length. The
pointer points to the original input string, so that there is no copy
(and this is the definition of a slice actually). Well, Zend Engine has
<a rel="noopener external" target="_blank" href="https://github.com/php/php-src/blob/52d91260df54995a680f420884338dfd9d5a0d49/Zend/zend_API.h#L563-L565">a <code>ZVAL_STRINGL</code>
macro</a>
that allows to create a string from a pointer and a length, great!
Unfortunately for us, Zend Engine does <a rel="noopener external" target="_blank" href="https://github.com/php/php-src/blob/52d91260df54995a680f420884338dfd9d5a0d49/Zend/zend_string.h#L152-L159">a copy behind the
scene</a>‚Ä¶
There is no way to keep the pointer and the length only, but it keeps
the number of copies small. I think it is to take the full ownership of
the data, which is required for the garbage collector.</p>
<pre class="giallo z-code"><code data-lang="c"><span class="giallo-l"><span class="z-comment">// 2. Create the Gutenberg_Parser_Block object.</span></span>
<span class="giallo-l"><span class="z-entity z-name z-function">object_init_ex</span><span class="z-punctuation z-section">(</span><span class="z-keyword z-operator">&amp;</span><span class="z-variable z-parameter">php_block</span><span class="z-punctuation z-separator">,</span><span> gutenberg_parser_block_class_entry</span><span class="z-punctuation z-section">)</span><span class="z-punctuation z-terminator">;</span></span></code></pre>
<p>The object has been instanciated with a class represented by the
<code>gutenberg_parser_block_class_entry</code>.</p>
<pre class="giallo z-code"><code data-lang="c"><span class="giallo-l"><span class="z-comment">// 3. Set the namespace and the name.</span></span>
<span class="giallo-l"><span class="z-entity z-name z-function">add_property_zval</span><span class="z-punctuation z-section">(</span><span class="z-keyword z-operator">&amp;</span><span class="z-variable z-parameter">php_block</span><span class="z-punctuation z-separator">,</span><span class="z-string"> &quot;namespace&quot;</span><span class="z-punctuation z-separator">,</span><span class="z-keyword z-operator"> &amp;</span><span class="z-variable z-parameter">php_block_namespace</span><span class="z-punctuation z-section">)</span><span class="z-punctuation z-terminator">;</span></span>
<span class="giallo-l"><span class="z-entity z-name z-function">add_property_zval</span><span class="z-punctuation z-section">(</span><span class="z-keyword z-operator">&amp;</span><span class="z-variable z-parameter">php_block</span><span class="z-punctuation z-separator">,</span><span class="z-string"> &quot;name&quot;</span><span class="z-punctuation z-separator">,</span><span class="z-keyword z-operator"> &amp;</span><span class="z-variable z-parameter">php_block_name</span><span class="z-punctuation z-section">)</span><span class="z-punctuation z-terminator">;</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span class="z-entity z-name z-function">zval_ptr_dtor</span><span class="z-punctuation z-section">(</span><span class="z-keyword z-operator">&amp;</span><span class="z-variable z-parameter">php_block_namespace</span><span class="z-punctuation z-section">)</span><span class="z-punctuation z-terminator">;</span></span>
<span class="giallo-l"><span class="z-entity z-name z-function">zval_ptr_dtor</span><span class="z-punctuation z-section">(</span><span class="z-keyword z-operator">&amp;</span><span class="z-variable z-parameter">php_block_name</span><span class="z-punctuation z-section">)</span><span class="z-punctuation z-terminator">;</span></span></code></pre>
<p>The <code>zval_ptr_dtor</code> adds 1 to the reference counter. This is required
for the garbage collector.</p>
<pre class="giallo z-code"><code data-lang="c"><span class="giallo-l"><span class="z-comment">// 4. Deal with block attributes if some.</span></span>
<span class="giallo-l"><span class="z-keyword">if</span><span class="z-punctuation z-section"> (</span><span>block.attributes.tag </span><span class="z-keyword z-operator">==</span><span> Some</span><span class="z-punctuation z-section">) {</span></span>
<span class="giallo-l"><span>    Slice_c_char attributes </span><span class="z-keyword z-operator">=</span><span class="z-variable"> block</span><span class="z-punctuation z-separator">.</span><span class="z-variable">attributes</span><span class="z-punctuation z-separator">.</span><span class="z-variable">some</span><span>.</span><span class="z-variable">_0</span><span class="z-punctuation z-terminator">;</span></span>
<span class="giallo-l"><span>    zval php_block_attributes</span><span class="z-punctuation z-terminator">;</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span class="z-entity z-name z-function">    ZVAL_STRINGL</span><span class="z-punctuation z-section">(</span><span class="z-keyword z-operator">&amp;</span><span>php_block_attributes</span><span class="z-punctuation z-separator">,</span><span class="z-variable"> attributes</span><span class="z-punctuation z-separator">.</span><span class="z-variable">pointer</span><span class="z-punctuation z-separator">,</span><span class="z-variable"> attributes</span><span class="z-punctuation z-separator">.</span><span class="z-variable">length</span><span class="z-punctuation z-section">)</span><span class="z-punctuation z-terminator">;</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span class="z-comment">    // 5. Set the attributes.</span></span>
<span class="giallo-l"><span class="z-entity z-name z-function">    add_property_zval</span><span class="z-punctuation z-section">(</span><span class="z-keyword z-operator">&amp;</span><span>php_block</span><span class="z-punctuation z-separator">,</span><span class="z-string"> &quot;attributes&quot;</span><span class="z-punctuation z-separator">,</span><span class="z-keyword z-operator"> &amp;</span><span>php_block_attributes</span><span class="z-punctuation z-section">)</span><span class="z-punctuation z-terminator">;</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span class="z-entity z-name z-function">    zval_ptr_dtor</span><span class="z-punctuation z-section">(</span><span class="z-keyword z-operator">&amp;</span><span>php_block_attributes</span><span class="z-punctuation z-section">)</span><span class="z-punctuation z-terminator">;</span></span>
<span class="giallo-l"><span class="z-punctuation z-section">}</span></span></code></pre>
<p>It is similar to what has been done for <code>namespace</code> and <code>name</code>. Now
let&#39;s continue with children.</p>
<pre class="giallo z-code"><code data-lang="c"><span class="giallo-l"><span class="z-comment">// 6. Handle children.</span></span>
<span class="giallo-l"><span class="z-storage">const</span><span> Vector_Node </span><span class="z-keyword z-operator">*</span><span>children </span><span class="z-keyword z-operator">=</span><span class="z-punctuation z-section"> (</span><span class="z-storage">const</span><span> Vector_Node</span><span class="z-keyword z-operator">*</span><span class="z-punctuation z-section">) (</span><span>block.children</span><span class="z-punctuation z-section">)</span><span class="z-punctuation z-terminator">;</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span class="z-keyword">if</span><span class="z-punctuation z-section"> (</span><span>children</span><span class="z-keyword z-operator">-&gt;</span><span>length </span><span class="z-keyword z-operator">&gt;</span><span class="z-constant z-numeric"> 0</span><span class="z-punctuation z-section">) {</span></span>
<span class="giallo-l"><span>    zval php_children_array</span><span class="z-punctuation z-terminator">;</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span class="z-entity z-name z-function">    array_init_size</span><span class="z-punctuation z-section">(</span><span class="z-keyword z-operator">&amp;</span><span>php_children_array</span><span class="z-punctuation z-separator">,</span><span class="z-variable"> children</span><span class="z-punctuation z-separator">-&gt;</span><span class="z-variable">length</span><span class="z-punctuation z-section">)</span><span class="z-punctuation z-terminator">;</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span class="z-comment">    // Recursion.</span></span>
<span class="giallo-l"><span class="z-entity z-name z-function">    into_php_objects</span><span class="z-punctuation z-section">(</span><span class="z-keyword z-operator">&amp;</span><span>php_children_array</span><span class="z-punctuation z-separator">,</span><span> children</span><span class="z-punctuation z-section">)</span><span class="z-punctuation z-terminator">;</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span class="z-comment">    // 7. Set the children.</span></span>
<span class="giallo-l"><span class="z-entity z-name z-function">    add_property_zval</span><span class="z-punctuation z-section">(</span><span class="z-keyword z-operator">&amp;</span><span>php_block</span><span class="z-punctuation z-separator">,</span><span class="z-string"> &quot;children&quot;</span><span class="z-punctuation z-separator">,</span><span class="z-keyword z-operator"> &amp;</span><span>php_children_array</span><span class="z-punctuation z-section">)</span><span class="z-punctuation z-terminator">;</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span class="z-entity z-name z-function">    Z_DELREF</span><span class="z-punctuation z-section">(</span><span>php_children_array</span><span class="z-punctuation z-section">)</span><span class="z-punctuation z-terminator">;</span></span>
<span class="giallo-l"><span class="z-punctuation z-section">}</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span class="z-entity z-name z-function">free</span><span class="z-punctuation z-section">((</span><span class="z-storage z-type">void</span><span class="z-keyword z-operator">*</span><span class="z-punctuation z-section">)</span><span class="z-variable z-parameter"> children</span><span class="z-punctuation z-section">)</span><span class="z-punctuation z-terminator">;</span></span></code></pre>
<p>Finally, add the block instance into the array to be returned:</p>
<pre class="giallo z-code"><code data-lang="c"><span class="giallo-l"><span class="z-comment">    // 8. Insert the object in the collection.</span></span>
<span class="giallo-l"><span class="z-entity z-name z-function">    add_next_index_zval</span><span class="z-punctuation z-section">(</span><span>php_array</span><span class="z-punctuation z-separator">,</span><span class="z-keyword z-operator"> &amp;</span><span class="z-variable z-parameter">php_block</span><span class="z-punctuation z-section">)</span><span class="z-punctuation z-terminator">;</span></span></code></pre>
<p><a rel="noopener external" target="_blank" href="https://github.com/Hywan/gutenberg-parser-rs/blob/master/bindings/php/extension/gutenberg_post_parser/gutenberg_post_parser.c">The entire code lands
here</a>.</p>
<h2 id="-3">PHP extension üöÄ PHP userland<a role="presentation" class="anchor" href="#-3" title="Anchor link to this header">#</a>
</h2>
<p>Now the extension is written, we have to compile it. That&#39;s the
repetitive set of commands we have shown above with <code>phpize</code>. Once the
extension is compiled, the generated <code>gutenberg_post_parser.so</code> file
must be located in the extension directory. This directory can be found
with the following command:</p>
<pre class="giallo z-code"><code data-lang="shellsession"><span class="giallo-l"><span class="z-punctuation z-separator">$</span><span> php-config --extension-dir</span></span></code></pre>
<p>For instance, in my computer, the extension directory is
<code>/usr/local/Cellar/php/7.2.11/pecl/20170718</code>.</p>
<p>Then, to enable the extension for a given execution, you must write:</p>
<pre class="giallo z-code"><code data-lang="shellsession"><span class="giallo-l"><span class="z-punctuation z-separator">$</span><span> php -d</span><span class="z-variable"> extension</span><span class="z-keyword z-operator">=</span><span class="z-string">gutenberg_post_parser</span><span class="z-entity z-name"> -m</span><span class="z-keyword z-operator"> |</span><span> \</span></span>
<span class="giallo-l"><span>      grep gutenberg_post_parser</span></span></code></pre>
<p>Or, to enable the extension for all executions, locate the <code>php.ini</code>
file with <code>php --ini</code> and edit it to add:</p>
<pre class="giallo z-code"><code data-lang="shellsession"><span class="giallo-l"><span>extension=gutenberg_post_parser</span></span></code></pre>
<p>Done!</p>
<p>Now, let&#39;s use some reflection to check the extension is correctly
loaded and handled by PHP:</p>
<pre class="giallo z-code"><code data-lang="shellsession"><span class="giallo-l"><span class="z-punctuation z-separator">$</span><span> php --re gutenberg_post_parser</span></span>
<span class="giallo-l"><span>Extension [ &lt;persistent&gt; extension #64 gutenberg_post_parser version 0.1.0 ] {</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>  - Functions {</span></span>
<span class="giallo-l"><span>    Function [ &lt;internal:gutenberg_post_parser&gt; function gutenberg_post_parse ] {</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>      - Parameters [1] {</span></span>
<span class="giallo-l"><span>        Parameter #0 [ &lt;required&gt; $gutenberg_post_as_string ]</span></span>
<span class="giallo-l"><span>      }</span></span>
<span class="giallo-l"><span>    }</span></span>
<span class="giallo-l"><span>  }</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>  - Classes [2] {</span></span>
<span class="giallo-l"><span>    Class [ &lt;internal:gutenberg_post_parser&gt; final class Gutenberg_Parser_Block ] {</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>      - Constants [0] {</span></span>
<span class="giallo-l"><span>      }</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>      - Static properties [0] {</span></span>
<span class="giallo-l"><span>      }</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>      - Static methods [0] {</span></span>
<span class="giallo-l"><span>      }</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>      - Properties [4] {</span></span>
<span class="giallo-l"><span>        Property [ &lt;default&gt; public $namespace ]</span></span>
<span class="giallo-l"><span>        Property [ &lt;default&gt; public $name ]</span></span>
<span class="giallo-l"><span>        Property [ &lt;default&gt; public $attributes ]</span></span>
<span class="giallo-l"><span>        Property [ &lt;default&gt; public $children ]</span></span>
<span class="giallo-l"><span>      }</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>      - Methods [0] {</span></span>
<span class="giallo-l"><span>      }</span></span>
<span class="giallo-l"><span>    }</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    Class [ &lt;internal:gutenberg_post_parser&gt; final class Gutenberg_Parser_Phrase ] {</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>      - Constants [0] {</span></span>
<span class="giallo-l"><span>      }</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>      - Static properties [0] {</span></span>
<span class="giallo-l"><span>      }</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>      - Static methods [0] {</span></span>
<span class="giallo-l"><span>      }</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>      - Properties [1] {</span></span>
<span class="giallo-l"><span>        Property [ &lt;default&gt; public $content ]</span></span>
<span class="giallo-l"><span>      }</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>      - Methods [0] {</span></span>
<span class="giallo-l"><span>      }</span></span>
<span class="giallo-l"><span>    }</span></span>
<span class="giallo-l"><span>  }</span></span>
<span class="giallo-l"><span>}</span></span></code></pre>
<p>Everything looks good: There is one function and two classes that are
defined as expected. Now, let&#39;s write some PHP code for the first time
in this blog post!</p>
<pre class="giallo z-code"><code data-lang="php"><span class="giallo-l"><span class="z-keyword z-operator">&lt;?</span><span class="z-constant z-other">php</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span class="z-support z-function">var_dump</span><span>(</span></span>
<span class="giallo-l"><span class="z-entity z-name z-function">¬†¬†¬† gutenberg_post_parse</span><span>(</span></span>
<span class="giallo-l"><span class="z-string">        &#39;&lt;!-- wp:foo /--&gt;bar&lt;!-- wp:baz --&gt;qux&lt;!-- /wp:baz --&gt;&#39;</span></span>
<span class="giallo-l"><span>    )</span></span>
<span class="giallo-l"><span>)</span><span class="z-punctuation z-terminator">;</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span class="z-comment">/**</span></span>
<span class="giallo-l"><span class="z-comment">¬†* Will output:</span></span>
<span class="giallo-l"><span class="z-comment"> *     array(3) {</span></span>
<span class="giallo-l"><span class="z-comment"> *       [0]=&gt;</span></span>
<span class="giallo-l"><span class="z-comment"> *       object(Gutenberg_Parser_Block)#1 (4) {</span></span>
<span class="giallo-l"><span class="z-comment"> *         [&quot;namespace&quot;]=&gt;</span></span>
<span class="giallo-l"><span class="z-comment"> *         string(4) &quot;core&quot;</span></span>
<span class="giallo-l"><span class="z-comment"> *         [&quot;name&quot;]=&gt;</span></span>
<span class="giallo-l"><span class="z-comment"> *         string(3) &quot;foo&quot;</span></span>
<span class="giallo-l"><span class="z-comment"> *         [&quot;attributes&quot;]=&gt;</span></span>
<span class="giallo-l"><span class="z-comment"> *         NULL</span></span>
<span class="giallo-l"><span class="z-comment"> *         [&quot;children&quot;]=&gt;</span></span>
<span class="giallo-l"><span class="z-comment"> *         NULL</span></span>
<span class="giallo-l"><span class="z-comment"> *       }</span></span>
<span class="giallo-l"><span class="z-comment"> *       [1]=&gt;</span></span>
<span class="giallo-l"><span class="z-comment"> *       object(Gutenberg_Parser_Phrase)#2 (1) {</span></span>
<span class="giallo-l"><span class="z-comment"> *         [&quot;content&quot;]=&gt;</span></span>
<span class="giallo-l"><span class="z-comment"> *         string(3) &quot;bar&quot;</span></span>
<span class="giallo-l"><span class="z-comment"> *       }</span></span>
<span class="giallo-l"><span class="z-comment"> *       [2]=&gt;</span></span>
<span class="giallo-l"><span class="z-comment"> *       object(Gutenberg_Parser_Block)#3 (4) {</span></span>
<span class="giallo-l"><span class="z-comment"> *         [&quot;namespace&quot;]=&gt;</span></span>
<span class="giallo-l"><span class="z-comment"> *         string(4) &quot;core&quot;</span></span>
<span class="giallo-l"><span class="z-comment"> *         [&quot;name&quot;]=&gt;</span></span>
<span class="giallo-l"><span class="z-comment"> *         string(3) &quot;baz&quot;</span></span>
<span class="giallo-l"><span class="z-comment"> *         [&quot;attributes&quot;]=&gt;</span></span>
<span class="giallo-l"><span class="z-comment"> *         NULL</span></span>
<span class="giallo-l"><span class="z-comment"> *         [&quot;children&quot;]=&gt;</span></span>
<span class="giallo-l"><span class="z-comment"> *         array(1) {</span></span>
<span class="giallo-l"><span class="z-comment"> *           [0]=&gt;</span></span>
<span class="giallo-l"><span class="z-comment"> *           object(Gutenberg_Parser_Phrase)#4 (1) {</span></span>
<span class="giallo-l"><span class="z-comment"> *             [&quot;content&quot;]=&gt;</span></span>
<span class="giallo-l"><span class="z-comment"> *             string(3) &quot;qux&quot;</span></span>
<span class="giallo-l"><span class="z-comment"> *           }</span></span>
<span class="giallo-l"><span class="z-comment"> *         }</span></span>
<span class="giallo-l"><span class="z-comment"> *       }</span></span>
<span class="giallo-l"><span class="z-comment"> *     }</span></span>
<span class="giallo-l"><span class="z-comment">¬†*/</span></span></code></pre>
<p>It works very well!</p>
<h2 id="-4">Conclusion<a role="presentation" class="anchor" href="#-4" title="Anchor link to this header">#</a>
</h2>
<p>The journey is:</p>
<ul>
<li>A string written in PHP,</li>
<li>Allocated by the Zend Engine from the Gutenberg extension,</li>
<li>Passed to Rust through FFI (static library + header),</li>
<li>Back to Zend Engine in the Gutenberg extension,</li>
<li>To generate PHP objects,</li>
<li>That are read by PHP.</li>
</ul>
<p>Rust fits really everywhere!</p>
<p>We have seen in details how to write a real world parser in Rust, how to
bind it to C and compile it to a static library in addition to C
headers, how to create a PHP extension exposing one function and two
objects, how to integrate the C binding into PHP, and how to use this
extension in PHP.</p>
<p>As a reminder, the C binding is about 150 lines of code. The PHP
extension is about 300 lines of code, but substracting ‚Äúdecorations‚Äù
(the boilerplate to declare and manage the extension) that are
automatically generated, the PHP extension reduces to about 200 lines of
code. Once again, I find this is a small surface of code to review
considering the fact that the parser is still written in Rust, and
modifying the parser will not impact the bindings (except if the AST is
updated obviously)!</p>
<p>PHP is a language with a garbage collector. It explains why all strings
are copied, so that they are owned by PHP itself. However, the fact that
Rust does not copy any data saves memory allocations and deallocations,
which is the biggest cost most of the time.</p>
<p>Rust also provides safety. This property can be questionned considering
the number of binding we are going through: Rust to C to PHP: Does it
still hold? From the Rust perspective, yes, but everything that happens
inside C or PHP must be considered unsafe. A special care must be put in
the C binding to handle all situations.</p>
<p>Is it still fast? Well, let&#39;s benchmark. I would like to remind that the
first goal of this experiment was to tackle the bad performance of the
original PEG.js parser. On the JavaScript ground, WASM and ASM.js have
shown to be very much faster (see <a href="https://mnt.io/series/from-rust-to-beyond/the-webassembly-galaxy/">the WebAssembly
galaxy</a>,
and <a href="https://mnt.io/series/from-rust-to-beyond/the-asm-js-galaxy/">the ASM.js
galaxy</a>).
For PHP, <a rel="noopener external" target="_blank" href="https://github.com/nylen/phpegjs"><code>phpegjs</code> is used</a>: It reads
the grammar written for PEG.js and compiles it to PHP. Let&#39;s see how
they compare:</p>
<figure>
<table><thead><tr><th>Document</th><th>PEG PHP parser (ms)</th><th>Rust parser as a PHP extension (ms)</th><th>speedup</th></tr></thead><tbody>
<tr><td><a rel="noopener external" target="_blank" href="https://raw.githubusercontent.com/dmsnell/gutenberg-document-library/master/library/demo-post.html"><code>demo-post.html</code></a></td><td>30.409</td><td>0.0012</td><td>√ó 25341</td></tr>
<tr><td><a rel="noopener external" target="_blank" href="https://raw.githubusercontent.com/dmsnell/gutenberg-document-library/master/library/shortcode-shortcomings.html"><code>shortcode-shortcomings.html</code></a></td><td>76.39</td><td>0.096</td><td>√ó 796</td></tr>
<tr><td><a rel="noopener external" target="_blank" href="https://raw.githubusercontent.com/dmsnell/gutenberg-document-library/master/library/redesigning-chrome-desktop.html"><code>redesigning-chrome-desktop.html</code></a></td><td>225.824</td><td>0.399</td><td>√ó 566</td></tr>
<tr><td><a rel="noopener external" target="_blank" href="https://raw.githubusercontent.com/dmsnell/gutenberg-document-library/master/library/web-at-maximum-fps.html"><code>web-at-maximum-fps.html</code></a></td><td>173.495</td><td>0.275</td><td>√ó 631</td></tr>
<tr><td><a rel="noopener external" target="_blank" href="https://raw.githubusercontent.com/dmsnell/gutenberg-document-library/master/library/early-adopting-the-future.html"><code>early-adopting-the-future.html</code></a></td><td>280.433</td><td>0.298</td><td>√ó 941</td></tr>
<tr><td><a rel="noopener external" target="_blank" href="https://raw.githubusercontent.com/dmsnell/gutenberg-document-library/master/library/pygmalian-raw-html.html"><code>pygmalian-raw-html.html</code></a></td><td>377.392</td><td>0.052</td><td>√ó 7258</td></tr>
<tr><td><a rel="noopener external" target="_blank" href="https://raw.githubusercontent.com/dmsnell/gutenberg-document-library/master/library/moby-dick-parsed.html"><code>moby-dick-parsed.html</code></a></td><td>5,437.630</td><td>5.037</td><td>√ó 1080</td></tr>
</tbody></table>
  <figcaption>
<p>Benchmarks between PEG PHP parser and Rust parser as a PHP extension.</p>
  </figcaption>
</figure>
<p>The PHP extension of the Rust parser is in average 5230 times faster
than the actual PEG PHP implementation. The median of the speedup is
941.</p>
<p>Another huge issue was that the PEG parser was not able to handle many
Gutenberg documents because of a memory limit. Of course, it is possible
to grow the size of the memory, but it is not ideal. With the Rust
parser as a PHP extension, memory stays constant and close to the size
of the parsed document.</p>
<p>I reckon we can optimise the extension further to generate an iterator
instead of an array. This is something I want to explore and analyse the
impact on the performance. The PHP Internals Book has a <a rel="noopener external" target="_blank" href="http://www.phpinternalsbook.com/classes_objects/iterators.html">chapter about
Iterators</a>.</p>
<p>Thanks for reading!</p>


    <nav class="previous-next-episodes"><a href="https:&#x2F;&#x2F;mnt.io&#x2F;series&#x2F;from-rust-to-beyond&#x2F;the-c-galaxy&#x2F;" class="button text-align-start">‚ùÆ&nbsp;The C galaxy</a></nav>
  </article>

</main>

<footer class="full-width content-grid">
  <div class="footer">
    <div>
      <h2>Contact me</h2>

      <ul>
        <li><a href="https://matrix.to/#/@mnt_io:matrix.org" title="Say hi on Matrix">@mnt_io:matrix.org</a></li>
        <li><a href="mailto:ivan@mnt.io" title="Good ol' email">ivan@mnt.io</a></li>
        <li><a href="https://floss.social/@hywan" title="Say hi on Mastodon" rel="me">Mastodon</a></li>
        <li><a href="https://github.com/Hywan" title="Say hi on Github">Github</a></li>
      </ul>
    </div>
    <div>
      <h2>Recommendations</h2>

      <ul>
        <li><a href="https://fasterthanli.me/">fasterthanli.me</a></li>
        <li><a href="https://without.boats/blog/">without.boats</a></li>
        <li><a href="https://faultlore.com/blah/">faultlore</a></li>
        <li><a href="https://smallcultfollowing.com/babysteps/blog/">smallcultfollowing</a></li>
        <li><a href="https://orlp.net/blog/">orlp</a></li>
        <li><a href="https://blog.m-ou.se/">m-ou.se</a></li>
        <li><a href="https://nadrieril.github.io/">nadrieril</a></li>
      </ul>
    </div>

    <div>
      <h2>More</h2>

      <ul>
        <li><a href="https://mnt.io/lore/">Lore</a></li>
        <li><a href="https://mnt.io/rss.xml">RSS</a></li>
        <li><a href="https://mnt.io/atom.xml">Atom</a></li>
        <li><a href="https://github.com/Hywan/mnt.io" title="Source code of this site">Source code</a></li>
        <li><a href="https://dblp.org/search/index.php?query=Ivan%20Enderlin" title="Computer Science Bibliography">DBLP</a></li>
      </ul>
    </div>
  </div>
</footer>

<script>
  window.addEventListener('DOMContentLoaded', (_event) => {
    new PagefindUI({
      element: "#search",
      resetStyles: false,
      showSubResults: true,
      showImages: false,
    });
  });
</script>
</body>
</html>
